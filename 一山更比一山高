1


题目是这样的：

以指定网址为根节点，遍历（深度优先、广度优先）访问 50 个页面并爬取这些页面上的所有网址。
代码

import re
import requests
from requests.exceptions import ReadTimeout, ConnectionError, RequestException
import urllib3
# 使用requests访问https时会有SSL验证，需要在get方法时关闭验证，同时会显示警告
urllib3.disable_warnings() # 用该行代码消除警告

visited = [] # 已经访问过（爬取过）的url。访问：即get该页面并取出该页面上的所有url
unvisited = [] # 已经取出的、但是还没有访问的/等待访问的url
url_count = 0 # 已经访问过的url数量
END_COUNT = 50 # 总共需要访问的url数量
end_flag = False # 标志是否该结束了（url_count >= END_COUNT）

# 访问页面：获取指定页面中含有的url
def visit(url, depth):
    visited.append(url) # 将该链接置为访问过
    try:
        req = requests.get(url, verify=False, timeout=5) # verify参数：关闭SSL验证
    except ReadTimeout: # 超时异常
        print('Timeout: ', url)
         ## 需要把当前的 url 放到任务中，过一段时间再尝试连接
    except ConnectionError: # 连接异常
        print('Connection error: ', url)
    except RequestException: # 请求异常
        print('Error: ', url)
    else:
        if req.status_code == 404:
            print('404页面不存在: ', url)
            ## 把当前的 url 从爬虫任务中删除掉
        if req.status_code == 403:
            print('403页面禁止访问: ', url)
            ## ... 
        if req.status_code == 200:

            # 如果正确访问，count+1；判断是否结束
            global url_count
            global end_flag
            url_count += 1
            if url_count >= END_COUNT:
                end_flag = True

            print("\t"*depth, "#%d-%d %s"%(depth, url_count, url))

            PATTERN_URl = "<a.*href=\"(https?://.*?)[\"|\'].*"
            ulist = re.findall(PATTERN_URl, req.text)
            ulist = [url for url in ulist if url.find(".pdf") == -1 ] # 为了防止下载pdf文件，特意跳过了：只保留没有".pdf"后缀的url

            return ulist
    return None


def dfs(url, depth=1):
    ulist = visit(url, depth)
    if ulist:
        ulist = list(set(ulist)-set(visited)) # ulist是局部变量，指的是一个节点的所有子节点
        for url in ulist:
            if depth<3 and not end_flag: # 只访问1、2、3层（根节点是第0层）
                dfs(url, depth+1)


def bfs(url):
    depth = 0
    global unvisited
    unvisited.append([url, depth])

    while(unvisited): # unvisited每个元素是[url, depth]
        [url, depth] = unvisited.pop(0)

        # 只访问1、2层
        if end_flag or depth >= 3:
            break
        
        ulist = visit(url, depth)
        if ulist:
            ulist = list(set(ulist)-set(visited))
            depth += 1 # ulist中的url都是当前url的孩子，所以深度加一
            unvisited = unvisited + [[url, depth] for url in ulist]

if __name__ == '__main__':
    start_url = "http://www.hzau.edu.cn"
    strategy = input("输入dfs/bfs：")
    if strategy == "dfs":
        print("\t"*0, "#%d %s"%(0, start_url))
        dfs(start_url)
    elif strategy == "bfs":
        bfs(start_url)
    else:
        print("输入格式有误，请重新输入")

结果截图


好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
2
0
« 上一篇： 编译原理系列 实验四语义分析与中间代码生成
posted @ 2020-06-06 20:13  小塞  阅读(624)  评论(1)  编辑  收藏  举报





2

目录

    实验四 语义分析与中间代码生成
        实验目的
        题目
        源程序

实验四 语义分析与中间代码生成
实验目的

    通过上机实习，加深对语法制导翻译原理的理解，掌握将语法分析所识别的语法范畴变换为某种中间代码的语义翻译方法。
    掌握目前普遍采用的语义分析方法──语法制导翻译技术。
    给出 PL/0 文法规范，要求在语法分析程序中添加语义处理，对于语法正确的表达式，输出其中间代码；对于语法正确的算术表达式，输出其计算值。

题目

【问题描述】
在实验二或实验三的表达式语法分析程序里，添加语义处理部分。 对于语法正确的表达式，输出其中间代码，用四元式序列表示；对于语法正确的算术表达式，输出其计算值。例如：当输入为2+35时，程序输出为17；当输入为a(b+c)时，程序输出为四元式：
(+,b,c,t1)
(,a,t1,t2)
要求源程序能智能判断这两种情况，并输出相应结果。
【输入形式】
（1） PL/0算术表达式的语义计算。PL/0算术表达式，例如:2+35作为输入。
（2）PL/0表达式的中间代码表示。输入：PL/0表达式，例如: a*(b+c)。

【输出形式】
2+35作为输入时，输出为17
a(b+c)作为输入时，输出为
(+,b,c,t1)
(*,a,t1,t2)
源程序

#include <iostream>
#include<bits/stdc++.h>

using namespace std;

/**词法分析及其结果存储**/
pair<string, string> lexRes[50]; // 词法分析结果，每个pair的first如"ident"，second如"a"
int lexI = 0; // lexRes的指针
void lexical()
/*词法分析：读入一行字符串，处理该字符串的词法分析结果至lexRes*/
/*lexI终为lexRes的长度，即单词数*/
{
    // 读入输入串
    string inputs; // 如，a*(b+c)
    cin >> inputs;

    // 初始化词典
    map<string,string> words;
    std::map<string,string>::iterator it;
    words["+"]="plus";
    words["-"]="minus";
    words["*"]="times";
    words["/"]="slash";
    words["="]="eql";
    words["("]="lparen";
    words[")"]="rparen";

    // 开始分析
    int insize=inputs.length();
    string word; // 输入符号，如"a"/"123"
    for(int i=0; i<insize; i++)
    {
        // 空白符跳过
        while(inputs[i] == ' ' || inputs[i] == '\n')
            i++;

        // 标志符/基本字捕捉
        if(isalpha(inputs[i])){
            // 拿出一个标志符/基本字
            word = inputs[i++];
            while(isalpha(inputs[i]) || isdigit(inputs[i]))
                word += inputs[i++];
            // 在map中找到相应的词性，并输出
            it = words.find(word);
            if(it != words.end())
                lexRes[lexI++] = make_pair(words[word], word);
                // cout << "(" << words[word] << "," << word << ")" << endl;
            else
                lexRes[lexI++] = make_pair("ident", word);
                // cout << "(ident" << "," << word << ")" << endl;
            i--;
        }

        // 常数
        else if(isdigit(inputs[i])){
            // 拿出常数
            word=inputs[i++];
            while(isdigit(inputs[i]))
                word+=inputs[i++];
            lexRes[lexI++] = make_pair("number", word);
            //cout << "(number" << "," << word << ")" << endl;
            i--;
        }

        // <、<=号
        else if(inputs[i]=='<'){
            word=inputs[i++];
            if(inputs[i]=='>'){
                word+=inputs[i];
                lexRes[lexI++] = make_pair(words[word], word);
                // cout << "(" << words[word] << "," << word << ")" << endl;
            }else if(inputs[i]=='='){
                word+=inputs[i];
                lexRes[lexI++] = make_pair(words[word], word);
                // cout << "(" <<words[word] << "," << word << ")" << endl;
            }else if(inputs[i]!=' '||!isdigit(inputs[i])||!isalpha(inputs[i])){
                lexRes[lexI++] = make_pair(words[word], word);
                // cout << "(" << words[word] << "," << word << ")" << endl;
            }else{
                //cout << "error!" << endl;
            }
            i--;
        }

        // >、>=
        else if(inputs[i]=='>'){
            word=inputs[i++];
            if(inputs[i]=='='){
                word+=inputs[i];
                lexRes[lexI++] = make_pair(words[word], word);
                // cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else if(inputs[i]!=' '||!isdigit(inputs[i])||!isalpha(inputs[i])){
                lexRes[lexI++] = make_pair(words[word], word);
                // cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
            i--;
        }

        //:=
        else if(inputs[i]==':'){
            word=inputs[i++];
            if(inputs[i]=='='){
                word+=inputs[i];
                lexRes[lexI++] = make_pair(words[word], word);
                // cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
            //i--;
        }

        //其他的基本字
        else{
            word=inputs[i];
            it=words.find(word);
            if(it!=words.end()){
                lexRes[lexI++] = make_pair(words[word], word);
                // cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
        }
    }

}


/**四元式相关，被调用**/
struct quad{
    string result;
    string arg1;
    string arg2;
    string op;
};
struct quad quad[50]; // 四元式数组
int quaI = 0; // 指向四元式的指针
void emit(string op, string arg1, string arg2, string result)
/*发射一行四元式*/
{
    quad[quaI].op = op;
    quad[quaI].arg1 = arg1;
    quad[quaI].arg2 = arg2;
    quad[quaI].result = result;
    quaI++;
}

int tI = 1; // 记录当前是t1/t2...t几了
string newT()
/*产生一个t1/t2...*/
{
    stringstream ss;
    ss << tI;
    string ti = "t" + ss.str();
    tI++;
    return ti;
}


/**非算数表达式的递归下降分析及四元式生成**/
// 指针前进
int sym=0; // 正在处理的单词
void advance()
{
    ++sym;
    if(sym > lexI){
        cout << "ERROR!sym指针越界";
        exit(0);
    }
}
string E();
string T();
string F();

string F()
/*因子分析*/
{
    string arg;
    if(lexRes[sym].first == "ident"){
        arg = lexRes[sym].second;
        advance();
    }
    else if(lexRes[sym].first == "number"){
        arg = lexRes[sym].second;
        advance();
    }
    else if(lexRes[sym].first == "lparen"){
        advance();
        arg = E();
        if(lexRes[sym].first == "rparen"){
            advance();
        }
        else{
            cout << "ERROR!未能匹配右括号！语法错误\n";
            exit(0);
        }
    }
    return arg;
}

string T()
/*项分析*/
{
    string op, arg1, arg2, result;
    arg1 = F();
    while(lexRes[sym].first == "times" || lexRes[sym].first == "slash"){
        op = lexRes[sym].second;
        advance();
        arg2 = F();
        result = newT();
        emit(op, arg1, arg2, result);
        arg1 = result;
    }
    return arg1;
}

string E()
/*表达式分析*/
{
    string op, arg1, arg2, result;
    if(lexRes[sym].first == "plus" || lexRes[sym].first == "minus"){
        advance();
    }
    arg1 = T();
    while(lexRes[sym].first == "plus" || lexRes[sym].first == "minus"){
        op = lexRes[sym].second;
        advance();
        arg2 = T();
        result = newT();
        emit(op, arg1, arg2, result);
        arg1 = result;
    }
    return arg1;
}


/**算数表达式的递归下降分析及四元式生成**/
int E_();
int T_();
int F_();

int F_()
{
    int arg;
    if(lexRes[sym].first == "ident"){
        cout << "算数表达式含变量，无法计算\n";
        exit(0);
    }
    else if(lexRes[sym].first == "number"){
        arg = atoi(lexRes[sym].second.c_str());
        advance();
    }
    else if(lexRes[sym].first == "lparen"){
        advance();
        arg = E_();
        if(lexRes[sym].first == "rparen"){
            advance();
        }
        else{
            cout << "ERROR!未能匹配右括号！语法错误\n";
            exit(0);
        }
    }
    return arg;
}

int T_()
/*项分析*/
{
    string op;
    int arg1, arg2, result;
    arg1 = F_();
    while(lexRes[sym].first == "times" || lexRes[sym].first == "slash"){
        op = lexRes[sym].second;
        advance();
        arg2 = F_();
        if(op == "*"){
            result = arg1 * arg2;
            arg1 = result;
        }
        else{
            if(arg2 != 0){
                result = arg1 / arg2;
                arg1 = result;
            }
            else {
                cout << "除数为0，出错！\n";
                exit(0);
            }
        }
    }
    return arg1;
}

int E_()
/*表达式分析*/
{
    string op;
    int arg1, arg2, result;
    if(lexRes[sym].first == "plus" || lexRes[sym].first == "minus"){
        advance();
    }
    arg1 = T_();
    while(lexRes[sym].first == "plus" || lexRes[sym].first == "minus"){
        op = lexRes[sym].second;
        advance();
        arg2 = T_();
        if(op == "+"){
            result = arg1 + arg2;
            arg1 = result;
        }
        else{
            result = arg1 - arg2;
            arg1 = result;
        }
    }
    return arg1;
}

int main()
{
    lexical(); 
    if(lexRes[0].first == "number"){
        cout << E_();
    }
    else{
        E();
        for(int i=0; i<quaI; i++){
            cout<<'('<<quad[i].op<<','<<quad[i].arg1<<','<<quad[i].arg2<<','<<quad[i].result<<')'<<endl;
        }
    }

    return 0;
}

image.png
image.png
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
1
0
« 上一篇： 编译原理系列 实验三自下而上语法分析
» 下一篇： 深度优先、广度优先python爬虫
posted @ 2020-05-16 23:56  小塞  阅读(3659)  评论(0)  编辑  收藏  举报





3

编译原理系列 实验三自下而上语法分析

    系列第三弹！

目录

    实验三 自下而上语法分析
        实验目的
        题目
        源程序
            实验结果

实验三 自下而上语法分析
实验目的

    给出 PL/0 文法规范，要求编写 PL/0 语言的语法分析程序。
    通过设计、编制、调试一个典型的自下而上语法分析程序，实现对词法分析程序所提供的单词序列进行语法检查和结构分析，进一步掌握常用的语法分析方法。
    选择最有代表性的语法分析方法，如算符优先分析法、LR 分析法；或者调研语法分析器的自动生成工具 YACC 的功能与工作原理，使用 YACC 生成一个自底向上的语法分析器。

题目

【问题描述】
考虑到大家用的编程语言不同，且实验一有少数同学没有得到正确结果，为不影响实验三的开展，实验三的输入统一采用词法分析器的输出结果为输入，输入形式如下：
【输入形式】
(lparen,()
(ident,a)
(plus,+)
(number,15)
(rparen,))
(times,*)
(ident,b)
【输出形式】
对于语法正确的表达式，报告“语法正确”，输出为“Yes,it is correct.”
对于语法错误的表达式，报告“语法错误”，输出为“No,it is wrong.”
【样例输入】

(lparen,()
(ident,a)
(plus,+)
(number,15)
(rparen,))
(times,*)
(ident,b)

【样例输出】

Yes,it is correct.

【测试数据】
系统给出两组测试数据：测试数据1：如以上样例输入输出；测试数据2的输入为：

(lparen,()
(ident,a)
(plus,+)
(number,15)
(rparen,))
(plus,+)
(times,*)
(ident,b)

测试数据2的输出为:

No,it is wrong.

源程序

优先关系表是手工算的。

#include <iostream>
#include <string.h>
#include<bits/stdc++.h>
#define N_VT 9

using namespace std;

// 优先关系表
int findP(int a, int b) // a、b ∈ [1,9]，之所以从1开始，是要适应in_vt的返回值
{
    int table[N_VT][N_VT] =  // 1表示>，-1表示<，0表示=，2表示空
        {{0,0,-1,-1,-1,-1,-1,1,1},
         {0,0,-1,-1,-1,-1,-1,1,1},
         {1,1,0,0,-1,-1,-1,1,1},
         {1,1,0,0,-1,-1,-1,1,1},
         {1,1,1,1,0,2,2,1,1},
         {1,1,1,1,2,0,2,1,1},
         {-1,-1,-1,-1,-1,-1,-1,0,1},
         {1,1,1,1,2,2,0,1,1},
         {-1,-1,-1,-1,-1,-1,-1,-1,0}};

    return table[a-1][b-1];
}

// 检查c是否是终结符，如果不是，返回0，如果是，返回它在算符优先表中的行号（从1开始）
int in_vt(char c)
{
    int n;
    switch(c)
    {
        case 'p': n=1; break;
        case 'm': n=2; break;
        case 't': n=3; break;
        case 's': n=4; break;
        case 'i': n=5; break;
        case 'n': n=6; break;
        case 'l': n=7; break;
        case 'r': n=8; break;
        case '#': n=9; break;
        default: n=0;
    }

    return n;
}

// 判断表达式的合法性
// p指向分析栈的首部，k指向栈顶；psc指向输入符号
// 暂时没有考虑到括号的匹配
int judge(char* p, int k, char* psc)
{
    if(k == 1 && p[k] == '#' && (*psc == 'p' || *psc == 'm' || *psc == 't' || *psc == 's'))
    {
        //printf("\n运算符前面没有操作数！\n");
        return 0;
    }
    if(*psc == '#' && (*(psc-1) == 'p' || *(psc-1) == 'm' || *(psc-1) == 't' || *(psc-1) == 's'))
    {
        //printf("\n运算符后面没有操作数！\n");
        return 0;
    }
    if(((*psc == 'p' || *psc == 'm' || *psc == 't' || *psc == 's') && ((*(psc+1) == 'p' || *(psc+1) == 'm' || *(psc+1) == 't' || *(psc+1) == 's'))))
    {
        //printf("\n运算符号相邻！\n");
        return 0;
    }
    return 1;
}

void getinputs(char* in_c)
{
    int i = 0;
    string line;
    while(cin >> line)
    {
        in_c[i++] = line[1];
    }
    in_c[i] = '#';
}

// 总控程序
int main()
{
    // 分析栈
    char s[30] = {'\0'};
    int k = 1; // 指向栈顶
    s[k] = '#';
    s[k+1] = '\0';
    int j; // 指向栈顶终结符
    char q; // j指向的元素，即栈顶终结符


    // 输入处理
    char in_c[50] = {'\0'}; // 输入串
    //printf("字符串是：%s\n", in_c);
    char *psc = in_c; // 指向当前输入符号

    int flag; // 查算符优先表得到的值（1/-1/0/2）(大于/小于/等于/空)

    // 分析总控程序
    while(1)
    {
        if(!judge(s, k, psc))
        {
            printf("No,it is wrong.");
            exit(1);
        }


        // 让j正确指向栈顶非终结符
        if(in_vt(s[k]))
            j = k;
        else
            j = k-1;


        // 根据s[j]和*psc的优先关系，判断移进规约
        flag = findP(in_vt(s[j]), in_vt(*psc));
        if(flag == 1) // s[j] > *psc，规约
        {
            // 找到规约范围
            do{
                q = s[j];// q保存当前的终结符

                // j向下探一（两）步，找到下一个终结符
                if(in_vt(s[j-1]))
                    j--;
                else
                    j-=2;
            }while(findP(in_vt(s[j]), in_vt(q)) != -1);

            // 规约
            k = j+1;
            s[k] = 'N'; // 管它规约成了哪个非终结符，不重要
            s[k+1] = '\0';

            continue;
        }
        else if(flag == -1)// s[j] < *psc，移进
        {
            k++;
            s[k] = *psc;
            s[k+1] = '\0';

            psc++;

            continue;
        }
        else if(flag == 0)
        {
            if(s[j] == '#')
            {
                printf("Yes,it is correct.");
                break;
            }
            else // 否则移进
            {
                k++;
                s[k] = *psc;
                s[k+1] = '\0';

                psc++;

                continue;
            }
        }
        else // 优先级表中空的地方
        {
            printf("No,it is wrong.");
            exit(1);
        }
    }

    return 0;
}

实验结果

image.png
image.png
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 编译原理系列 实验二自上而下语法分析
» 下一篇： 编译原理系列 实验四语义分析与中间代码生成
posted @ 2020-05-16 23:49  小塞  阅读(839)  评论(1)  编辑  收藏  举报




4


编译原理系列 实验三自下而上语法分析

    系列第三弹！

目录

    实验三 自下而上语法分析
        实验目的
        题目
        源程序
            实验结果

实验三 自下而上语法分析
实验目的

    给出 PL/0 文法规范，要求编写 PL/0 语言的语法分析程序。
    通过设计、编制、调试一个典型的自下而上语法分析程序，实现对词法分析程序所提供的单词序列进行语法检查和结构分析，进一步掌握常用的语法分析方法。
    选择最有代表性的语法分析方法，如算符优先分析法、LR 分析法；或者调研语法分析器的自动生成工具 YACC 的功能与工作原理，使用 YACC 生成一个自底向上的语法分析器。

题目

【问题描述】
考虑到大家用的编程语言不同，且实验一有少数同学没有得到正确结果，为不影响实验三的开展，实验三的输入统一采用词法分析器的输出结果为输入，输入形式如下：
【输入形式】
(lparen,()
(ident,a)
(plus,+)
(number,15)
(rparen,))
(times,*)
(ident,b)
【输出形式】
对于语法正确的表达式，报告“语法正确”，输出为“Yes,it is correct.”
对于语法错误的表达式，报告“语法错误”，输出为“No,it is wrong.”
【样例输入】

(lparen,()
(ident,a)
(plus,+)
(number,15)
(rparen,))
(times,*)
(ident,b)

【样例输出】

Yes,it is correct.

【测试数据】
系统给出两组测试数据：测试数据1：如以上样例输入输出；测试数据2的输入为：

(lparen,()
(ident,a)
(plus,+)
(number,15)
(rparen,))
(plus,+)
(times,*)
(ident,b)

测试数据2的输出为:

No,it is wrong.

源程序

优先关系表是手工算的。

#include <iostream>
#include <string.h>
#include<bits/stdc++.h>
#define N_VT 9

using namespace std;

// 优先关系表
int findP(int a, int b) // a、b ∈ [1,9]，之所以从1开始，是要适应in_vt的返回值
{
    int table[N_VT][N_VT] =  // 1表示>，-1表示<，0表示=，2表示空
        {{0,0,-1,-1,-1,-1,-1,1,1},
         {0,0,-1,-1,-1,-1,-1,1,1},
         {1,1,0,0,-1,-1,-1,1,1},
         {1,1,0,0,-1,-1,-1,1,1},
         {1,1,1,1,0,2,2,1,1},
         {1,1,1,1,2,0,2,1,1},
         {-1,-1,-1,-1,-1,-1,-1,0,1},
         {1,1,1,1,2,2,0,1,1},
         {-1,-1,-1,-1,-1,-1,-1,-1,0}};

    return table[a-1][b-1];
}

// 检查c是否是终结符，如果不是，返回0，如果是，返回它在算符优先表中的行号（从1开始）
int in_vt(char c)
{
    int n;
    switch(c)
    {
        case 'p': n=1; break;
        case 'm': n=2; break;
        case 't': n=3; break;
        case 's': n=4; break;
        case 'i': n=5; break;
        case 'n': n=6; break;
        case 'l': n=7; break;
        case 'r': n=8; break;
        case '#': n=9; break;
        default: n=0;
    }

    return n;
}

// 判断表达式的合法性
// p指向分析栈的首部，k指向栈顶；psc指向输入符号
// 暂时没有考虑到括号的匹配
int judge(char* p, int k, char* psc)
{
    if(k == 1 && p[k] == '#' && (*psc == 'p' || *psc == 'm' || *psc == 't' || *psc == 's'))
    {
        //printf("\n运算符前面没有操作数！\n");
        return 0;
    }
    if(*psc == '#' && (*(psc-1) == 'p' || *(psc-1) == 'm' || *(psc-1) == 't' || *(psc-1) == 's'))
    {
        //printf("\n运算符后面没有操作数！\n");
        return 0;
    }
    if(((*psc == 'p' || *psc == 'm' || *psc == 't' || *psc == 's') && ((*(psc+1) == 'p' || *(psc+1) == 'm' || *(psc+1) == 't' || *(psc+1) == 's'))))
    {
        //printf("\n运算符号相邻！\n");
        return 0;
    }
    return 1;
}

void getinputs(char* in_c)
{
    int i = 0;
    string line;
    while(cin >> line)
    {
        in_c[i++] = line[1];
    }
    in_c[i] = '#';
}

// 总控程序
int main()
{
    // 分析栈
    char s[30] = {'\0'};
    int k = 1; // 指向栈顶
    s[k] = '#';
    s[k+1] = '\0';
    int j; // 指向栈顶终结符
    char q; // j指向的元素，即栈顶终结符


    // 输入处理
    char in_c[50] = {'\0'}; // 输入串
    //printf("字符串是：%s\n", in_c);
    char *psc = in_c; // 指向当前输入符号

    int flag; // 查算符优先表得到的值（1/-1/0/2）(大于/小于/等于/空)

    // 分析总控程序
    while(1)
    {
        if(!judge(s, k, psc))
        {
            printf("No,it is wrong.");
            exit(1);
        }


        // 让j正确指向栈顶非终结符
        if(in_vt(s[k]))
            j = k;
        else
            j = k-1;


        // 根据s[j]和*psc的优先关系，判断移进规约
        flag = findP(in_vt(s[j]), in_vt(*psc));
        if(flag == 1) // s[j] > *psc，规约
        {
            // 找到规约范围
            do{
                q = s[j];// q保存当前的终结符

                // j向下探一（两）步，找到下一个终结符
                if(in_vt(s[j-1]))
                    j--;
                else
                    j-=2;
            }while(findP(in_vt(s[j]), in_vt(q)) != -1);

            // 规约
            k = j+1;
            s[k] = 'N'; // 管它规约成了哪个非终结符，不重要
            s[k+1] = '\0';

            continue;
        }
        else if(flag == -1)// s[j] < *psc，移进
        {
            k++;
            s[k] = *psc;
            s[k+1] = '\0';

            psc++;

            continue;
        }
        else if(flag == 0)
        {
            if(s[j] == '#')
            {
                printf("Yes,it is correct.");
                break;
            }
            else // 否则移进
            {
                k++;
                s[k] = *psc;
                s[k+1] = '\0';

                psc++;

                continue;
            }
        }
        else // 优先级表中空的地方
        {
            printf("No,it is wrong.");
            exit(1);
        }
    }

    return 0;
}

实验结果

image.png
image.png
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 编译原理系列 实验二自上而下语法分析
» 下一篇： 编译原理系列 实验四语义分析与中间代码生成
posted @ 2020-05-16 23:49  小塞  阅读(839)  评论(1)  编辑  收藏  举报





5


编译原理系列 实验二自上而下语法分析

    系列第二更！

目录

    实验二 自上而下语法分析
        实验目的
        题目
        设计思想
        源程序

实验二 自上而下语法分析
实验目的

    给出 PL/0 文法规范，要求编写 PL/0 语言的语法分析程序。
    通过设计、编制、调试一个典型的自上而下语法分析程序，实现对词法分析程序所提供的单词序列进行语法检查和结构分析，进一步掌握常用的语法分析方法。
    选择最有代表性的语法分析方法，如递归下降分析法、预测分析法；选择对各种常见程序语言都具备的语法结构，如赋值语句，特别是表达式，作为分析对象。

题目

【问题描述】
最基本的要求，能对一个算术表达式(a+15)*b做自上而下的语法分析，具体内容见实验指导实验二的内容，文法在实验指导最开始几页，重点关注以下几条文法的EBNF，若不习惯看文法的巴科斯范式EBNF,可先将文法改写成常规的产生式形式P75：
<表达式> ::= [+|-]<项>{<加法运算符> <项>}
<项> ::= <因子>{<乘法运算符> <因子>}
<因子> ::= <标识符>|<无符号整数>| ‘(’<表达式>‘)’
<加法运算符> ::= +|-
<乘法运算符> ::= *|/
考虑到大家用的编程语言不同，且实验一有少数同学没有得到正确结果，为不影响实验二的开展，实验二的输入统一采用词法分析器的输出结果为输入。输入形式如下：
【输入形式】

(lparen,()
(ident,a)
(plus,+)
(number,15)
(rparen,))
(times,*)
(ident,b)

【输出形式】
对于语法正确的表达式，报告“语法正确”，输出为“Yes,it is correct.”
对于语法错误的表达式，报告“语法错误”，输出为“No,it is wrong.”
【样例输入】

(lparen,()
(ident,a)
(plus,+)
(number,15)
(rparen,))
(times,*)
(ident,b)

【样例输出】

Yes,it is correct.

补充说明：学有余力的同学，可以在完成本实验后思考如何将词法分析的程序和语法分析的程序写在一起？以语法分析程序为主程序，词法分析程序为被调用程序，直接用(a+15)b做输入。（注意：这个扩展的写法请不要传到编程题！！！可以写在实验报告中。因为实验二的编程题的测试输入形式我给的不是(a+15)b，而是用(a+15)*b的词法分析的输出作为实验二语法分析的输入，如上面的样例输入形式。）
设计思想

选择递归下降分析方法：
1.设计出每个非终结符的文法识别过程
2.将输入数据进行处理，提取出单词的编码
3.为每个非终结符写识别递归函数
4.函数相互调用
源程序

数据读入和错误处理部分我处理的不是很妥当，对于这个题目是OK的，但是不健壮。

#include <iostream>
#include <string>
#include<bits/stdc++.h>
#define N 8
using namespace std;

string words[N];//每个元素都是“lparen”/“ident”这样的标志符
int sym=0;//words的指针

// 函数声明
void E();
void T();
void F();
// 填充words数组
void getwords()
{
    string line;
    for(int i=0; i<N-1; i++)
    {
        cin >> line;
        int pos = line.find(',', 0);
        words[i] = line.substr(1, pos-1);
        // cout << words[i];
    }
}

// 指针前进
void advance()
{
    ++sym;
    if(sym > N-1){
        cout << "ERROR!words指针越界";
        exit(0);
    }
}
// 因子分析
void F()
{
    //cout << "F正在分析" << words[sym] << endl;

    if(words[sym] == "ident"){
        advance();
    }
    else if(words[sym] == "number") {
        advance();
    }
    else if(words[sym] == "lparen") {
        advance();
        E();
        //cout << "E返回，F正在分析" << words[sym] << endl;
        if(words[sym] == "rparen") {
            advance();
        }
        else {
            //cout << "ERROR!未能匹配右括号！语法错误" << endl;
            exit(0);
        }
    }
    return;
}

// 项分析
void T()
{
    //cout << "T正在分析" << words[sym] << endl;

    F();
    //cout << "1F返回，T正在分析" << words[sym] << endl;
    while(words[sym] == "times" || words[sym] == "slash"){
        advance();
        F();
        //cout << "2F返回，T正在分析" << words[sym] << endl;
    }
    return;
}

// 表达式分析
void E()
{
    //cout << "E正在分析" << words[sym] << endl;

    if(words[sym] == "plus" || words[sym] == "minus"){
        advance();
    }

    T();
    //cout << "1T返回，E正在分析" << words[sym] << endl;

    while(words[sym] == "plus" || words[sym] == "minus") {
        advance();
        T();
        //cout << "2T返回，E正在分析" << words[sym] << endl;
    }
    return;
}
int main()
{
    getwords();
    E();
    if(sym == N-1) {
        cout << "Yes,it is correct." << endl;
    }
    else {
        cout << "No,it is wrong.";
    }

    return 0;
}

image.png
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 编译原理系列 实验一词法分析
» 下一篇： 编译原理系列 实验三自下而上语法分析
posted @ 2020-05-16 23:43  小塞  阅读(935)  评论(0)  编辑  收藏  举报



6

编译原理系列 实验一词法分析

    刚好把四次实验都给做完了，在实验过程中发现学长学姐留下的实验参考不太够……就留下我的实验结果供大家参考吧~

目录

    实验一 词法分析实验
        一、实验目的
        二、题目
        三、源程序

实验一 词法分析实验
一、实验目的

根据PL/0语言的文法规范，编写PL/0语言的词法分析程序。要求：
把词法分析器设计成一个独立一遍的过程。
词法分析器的输出形式采用二元式序列，即：(单词种类, 单词的值）。
二、题目

【样例输入】

const a=10;
var b,c;
begin
read(b);
c:=a+b;
write(c)
end.

【样例输出】

(constsym,const)
(ident,a)
(eql,=)
(number,10)
(semicolon,;)
(varsym,var)
(ident,b)
(comma,,)
(ident,c)
(semicolon,;)
(beginsym,begin)
(readsym,read)
(lparen,()
(ident,b)
(rparen,))
(semicolon,;)
(ident,c)
(becomes,:=)
(ident,a)
(plus,+)
(ident,b)
(semicolon,;)
(writesym,write)
(lparen,()
(ident,c)
(rparen,))
(endsym,end)
(period,.)

三、源程序

#include<fstream>
#include<cstring>
#include<string>
#include<fstream>
#include<sstream>
#include<iostream>
#include<map>
#include<bits/stdc++.h>
using namespace std;

map<string,string> words;
std::map<string,string>::iterator it;//words的指针
void words_init(){//对应关系进行初始化
    words["+"]="plus";
    words["-"]="minus";
    words["*"]="times";
    words["/"]="slash";
    words["="]="eql";
    words["<>"]="neq";
    words["<"]="lss";
    words["<="]="leq";
    words[">"]="gtr";
    words[">="]="geq";
    words[":="]="becomes";
    words["("]="lparen";
    words[")"]="rparen";
    words[","]="comma";
    words[";"]="semicolon";
    words["."]="period";
    words["read"]="readsym";
    words["then"]="thensym";
    words["if"]="ifsym";
    words["odd"]="oddsym";
    words["procedure"]="proceduresym";
    words["var"]="varsym";
    words["while"]="whilesym";
    words["write"]="writesym";
    words["begin"]="beginsym";
    words["do"]="dosym";
    words["end"]="endsym";
    words["call"]="callsym";
    words["const"]="constsym";
}

int main(){
    words_init();//初始化

    // 读入输入串
    char ins[100];
    int i=0;
    ins[i] = getchar();
    while(ins[i] != '.'){
        ins[++i] = getchar();
    }
    string inputs = ins;

    // 处理输入串
    int insize=inputs.length();
    string word;
    for(int i=0; i<insize; i++)
    {
        // 空白符跳过
        while(inputs[i] == ' ' || inputs[i] == '\n')
            i++;

        // 标志符/基本字捕捉
        if(isalpha(inputs[i])){
            // 拿出一个标志符/基本字
            word = inputs[i++];
            while(isalpha(inputs[i]) || isdigit(inputs[i]))
                word += inputs[i++];
            // 在map中找到相应的词性，并输出
            it = words.find(word);
            if(it != words.end())
                cout << "(" << words[word] << "," << word << ")" << endl;
            else
                cout << "(ident" << "," << word << ")" << endl;
            i--;
        }

        // 常数
        else if(isdigit(inputs[i])){
            // 拿出常数
            word=inputs[i++];
            while(isdigit(inputs[i]))
                word+=inputs[i++];
            cout << "(number" << "," << word << ")" << endl;
            i--;
        }

        // <、<=号
        else if(inputs[i]=='<'){
            word=inputs[i++];
            if(inputs[i]=='>'){
                word+=inputs[i];
                cout << "(" << words[word] << "," << word << ")" << endl;
            }else if(inputs[i]=='='){
                word+=inputs[i];
                cout << "(" <<words[word] << "," << word << ")" << endl;
            }else if(inputs[i]!=' '||!isdigit(inputs[i])||!isalpha(inputs[i])){
                cout << "(" << words[word] << "," << word << ")" << endl;
            }else{
                //cout << "error!" << endl;
            }
            i--;
        }

        // >、>=
        else if(inputs[i]=='>'){
            word=inputs[i++];
            if(inputs[i]=='='){
                word+=inputs[i];
                cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else if(inputs[i]!=' '||!isdigit(inputs[i])||!isalpha(inputs[i])){
                cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
            i--;
        }

        //:=
        else if(inputs[i]==':'){
            word=inputs[i++];
            if(inputs[i]=='='){
                word+=inputs[i];
                cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
            //i--;
        }

        //其他的基本字
        else{
            word=inputs[i];
            it=words.find(word);
            if(it!=words.end()){
                cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
        }
    }

    return 0;
}

image.png
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 【Q&A】pytorch中的worker如何工作的
» 下一篇： 编译原理系列 实验二自上而下语法分析
posted @ 2020-05-16 23:36  小塞  阅读(477)  评论(0)  编辑  收藏  举报



7


编译原理系列 实验一词法分析

    刚好把四次实验都给做完了，在实验过程中发现学长学姐留下的实验参考不太够……就留下我的实验结果供大家参考吧~

目录

    实验一 词法分析实验
        一、实验目的
        二、题目
        三、源程序

实验一 词法分析实验
一、实验目的

根据PL/0语言的文法规范，编写PL/0语言的词法分析程序。要求：
把词法分析器设计成一个独立一遍的过程。
词法分析器的输出形式采用二元式序列，即：(单词种类, 单词的值）。
二、题目

【样例输入】

const a=10;
var b,c;
begin
read(b);
c:=a+b;
write(c)
end.

【样例输出】

(constsym,const)
(ident,a)
(eql,=)
(number,10)
(semicolon,;)
(varsym,var)
(ident,b)
(comma,,)
(ident,c)
(semicolon,;)
(beginsym,begin)
(readsym,read)
(lparen,()
(ident,b)
(rparen,))
(semicolon,;)
(ident,c)
(becomes,:=)
(ident,a)
(plus,+)
(ident,b)
(semicolon,;)
(writesym,write)
(lparen,()
(ident,c)
(rparen,))
(endsym,end)
(period,.)

三、源程序

#include<fstream>
#include<cstring>
#include<string>
#include<fstream>
#include<sstream>
#include<iostream>
#include<map>
#include<bits/stdc++.h>
using namespace std;

map<string,string> words;
std::map<string,string>::iterator it;//words的指针
void words_init(){//对应关系进行初始化
    words["+"]="plus";
    words["-"]="minus";
    words["*"]="times";
    words["/"]="slash";
    words["="]="eql";
    words["<>"]="neq";
    words["<"]="lss";
    words["<="]="leq";
    words[">"]="gtr";
    words[">="]="geq";
    words[":="]="becomes";
    words["("]="lparen";
    words[")"]="rparen";
    words[","]="comma";
    words[";"]="semicolon";
    words["."]="period";
    words["read"]="readsym";
    words["then"]="thensym";
    words["if"]="ifsym";
    words["odd"]="oddsym";
    words["procedure"]="proceduresym";
    words["var"]="varsym";
    words["while"]="whilesym";
    words["write"]="writesym";
    words["begin"]="beginsym";
    words["do"]="dosym";
    words["end"]="endsym";
    words["call"]="callsym";
    words["const"]="constsym";
}

int main(){
    words_init();//初始化

    // 读入输入串
    char ins[100];
    int i=0;
    ins[i] = getchar();
    while(ins[i] != '.'){
        ins[++i] = getchar();
    }
    string inputs = ins;

    // 处理输入串
    int insize=inputs.length();
    string word;
    for(int i=0; i<insize; i++)
    {
        // 空白符跳过
        while(inputs[i] == ' ' || inputs[i] == '\n')
            i++;

        // 标志符/基本字捕捉
        if(isalpha(inputs[i])){
            // 拿出一个标志符/基本字
            word = inputs[i++];
            while(isalpha(inputs[i]) || isdigit(inputs[i]))
                word += inputs[i++];
            // 在map中找到相应的词性，并输出
            it = words.find(word);
            if(it != words.end())
                cout << "(" << words[word] << "," << word << ")" << endl;
            else
                cout << "(ident" << "," << word << ")" << endl;
            i--;
        }

        // 常数
        else if(isdigit(inputs[i])){
            // 拿出常数
            word=inputs[i++];
            while(isdigit(inputs[i]))
                word+=inputs[i++];
            cout << "(number" << "," << word << ")" << endl;
            i--;
        }

        // <、<=号
        else if(inputs[i]=='<'){
            word=inputs[i++];
            if(inputs[i]=='>'){
                word+=inputs[i];
                cout << "(" << words[word] << "," << word << ")" << endl;
            }else if(inputs[i]=='='){
                word+=inputs[i];
                cout << "(" <<words[word] << "," << word << ")" << endl;
            }else if(inputs[i]!=' '||!isdigit(inputs[i])||!isalpha(inputs[i])){
                cout << "(" << words[word] << "," << word << ")" << endl;
            }else{
                //cout << "error!" << endl;
            }
            i--;
        }

        // >、>=
        else if(inputs[i]=='>'){
            word=inputs[i++];
            if(inputs[i]=='='){
                word+=inputs[i];
                cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else if(inputs[i]!=' '||!isdigit(inputs[i])||!isalpha(inputs[i])){
                cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
            i--;
        }

        //:=
        else if(inputs[i]==':'){
            word=inputs[i++];
            if(inputs[i]=='='){
                word+=inputs[i];
                cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
            //i--;
        }

        //其他的基本字
        else{
            word=inputs[i];
            it=words.find(word);
            if(it!=words.end()){
                cout<<"("<<words[word]<<","<<word<<")"<<endl;
            }else{
                //cout<<"error!"<<endl;
            }
        }
    }

    return 0;
}

image.png
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 【Q&A】pytorch中的worker如何工作的
» 下一篇： 编译原理系列 实验二自上而下语法分析
posted @ 2020-05-16 23:36  小塞  阅读(477)  评论(0)  编辑  收藏  举报



8


【Q&A】pytorch中的worker如何工作的

目录

    Question
    Answer
    参考资料


博客地址：https://www.cnblogs.com/hesse-summer/，欢迎转载，转载请说明出处。

Question

一直很迷，
在给Dataloader设置worker数量（num_worker）时，到底设置多少合适？这个worker到底怎么工作的？
如果将num_worker设为0（也是默认值），就没有worker了吗？

worker的使用场景：

from torch.utils.data import DataLoader

train_loader = DataLoader(dataset=train_data, batch_size=train_bs, shuffle=True, num_worker=4)

valid_loader = DataLoader(dataset=valid_data, batch_size=valid_bs, num_worker=4)

Answer

    每每轮到dataloader加载数据时：

    for epoch in range(start_epoch, end_epoch):
        for i, data in enumerate(trainloader):

    dataloader一次性创建num_worker个worker，（也可以说dataloader一次性创建num_worker个工作进程，worker也是普通的工作进程），

    并用batch_sampler将指定batch分配给指定worker，worker将它负责的batch加载进RAM。

    然后，dataloader从RAM中找本轮迭代要用的batch，如果找到了，就使用。如果没找到，就要num_worker个worker继续加载batch到内存，直到dataloader在RAM中找到目标batch。一般情况下都是能找到的，因为batch_sampler指定batch时当然优先指定本轮要用的batch。

    num_worker设置得大，好处是寻batch速度快，因为下一轮迭代的batch很可能在上一轮/上上一轮...迭代时已经加载好了。坏处是内存开销大，也加重了CPU负担（worker加载数据到RAM的进程是CPU复制的嘛）。num_workers的经验设置值是自己电脑/服务器的CPU核心数，如果CPU很强、RAM也很充足，就可以设置得更大些。

    如果num_worker设为0，意味着每一轮迭代时，dataloader不再有自主加载数据到RAM这一步骤（因为没有worker了），而是在RAM中找batch，找不到时再加载相应的batch。缺点当然是速度更慢。

参考资料

    https://stackoverflow.com/questions/53998282/how-does-the-number-of-workers-parameter-in-pytorch-dataloader-actually-work
    https://discuss.pytorch.org/t/guidelines-for-assigning-num-workers-to-dataloader/813

标签: pytorch
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
1
0
« 上一篇： 【教程】opencv-python+yolov3实现目标检测
» 下一篇： 编译原理系列 实验一词法分析
posted @ 2019-08-13 09:23  小塞  阅读(6598)  评论(0)  编辑  收藏  举报
刷新评论刷新页面返回顶部


9


【教程】opencv-python+yolov3实现目标检测

目录

    【教程】opencv-python+yolov3实现目标检测
        目标检测概况
            目标检测是？
            目标检测算法？
        yolov3模型简介
            性能介绍
            架构介绍
        opencv-python实现
            why opencv?
            正文
                先
            再

话说我发现自己之前辛辛苦苦写的一篇被人爬了............所以为了应对那种情况，我把自己的博客地址贴上吧...
本博客地址：小塞https://www.cnblogs.com/hesse-summer/
【教程】opencv-python+yolov3实现目标检测

因为最近的任务有用到目标检测，所以昨天晚上、今天上午搞了一下，快速地了解了目标检测这一任务，并且实现了使用opencv进行目标检测。

网上资料挺乱的，感觉在搜资源上浪费了我不少时间，所以我写这篇博客，把我这段时间了解到的东西整理起来，供有缘的读者参考学习。
目标检测概况
目标检测是？

目标检测，粗略来说就是：输入图片/视频，经过处理，得到：目标的位置信息（比如左上角和右下角的坐标）、目标的预测类别、目标的预测置信度（confidence）。

拿Faster R-CNN这个算法举例：输入一个batch（batch size也可以为1）的图片或者视频，网络直接的outputs是这样的：
[batchId, classId, confidence, left, top, right, bottom]，batchId, classId, confidence, left, top, right, bottom都是标量。
batchId表示这一个batch中，这张图片的id（也即index），后四个标量即目标的位置信息：左上角像素点和右下角像素点的坐标。
目标检测算法？

按照历史脉络来谈：

    手工特征提取算法，如VJ、HOG、DPM

    R-CNN算法（2014），最早的基于深度学习的目标检测器之一，其结构是两级网络：1）首先需要诸如选择性搜索之类的算法来提出可能包含对象的候选边界框；2）然后将这些区域传递到CNN算法进行分类；

    R-CNN算法存在的问题是其仿真很慢，并且不是完整的端到端的目标检测器。

    Fast R-CNN算法（2014末），对原始R-CNN进行了相当大的改进：提高准确度，并减少执行正向传递所花费的时间。

    但是，该模型仍然依赖于外部区域搜索算法。

    faster R-CNN算法（2015），真正的端到端深度学习目标检测器。删除了选择性搜索的要求，而是依赖于
    （1）完全卷积的区域提议网络（RPN, Region Purpose Network），可以预测对象边界框和“对象”分数（量化它是一个区域的可能性的分数）。
    （2）然后将RPN的输出传递到R-CNN组件以进行最终分类和标记。

    R-CNN系列算法，都采取了two-stage策略。特点是：虽然检测结果一般都非常准确，但仿真速度非常慢，即使是在GPU上也仅获得5 FPS。

    one-stage方法有：yolo（2015）、SSD（2015末），以及在这两个算法基础上改进的各论文提出的算法。这些算法的基本思路是：均匀地在图片的不同位置进行密集抽样，抽样时可以采用不同尺度和长宽比，然后利用CNN提取特征后直接进行分类与回归。
    整个过程只需要一步，所以其优势是速度快，但是训练比较困难。

    yolov3（2018）是yolo作者提出的第三个版本（之前还提过yolov2和它们的tinny版本，tinny版本经过压缩更快但是也降低了准确率）。yolov3支持80类物体的目标检测，完整列表[戳这里]: https://github.com/pjreddie/darknet/blob/master/data/coco.names

时间线：

yolov3模型简介
性能介绍

首先，套路，yolov3很强大（不强大我用它干啥呢）。速度上，它比 R-CNN 快 1000 倍，比 Fast R-CNN 快 100 倍。检测准确率上，它不是最准的：YOLOv3-608比 DSSD 更高，接近 FPN。但是它的速度不到后二者的1/3。

从下图也可以看出：

img
架构介绍

img

可以看出，他是一系列卷积、残差、上采样组成的。特点在于，它将预测分在三个尺度（Scale）进行（见图中三个彩色框），也在三个scale分别输出。
opencv-python实现
why opencv?

opencv（ 3.4.2+版本）的dnn（Deep Neural Network-DNN）模块封装了Darknet框架，这个框架是

自己写的，它由封装了yolo算法。因为这么一层关系，我们可以使用opencv方便地使用yolo的各个版本，而且有数据（见下）证明OpenCV的DNN模块在 CPU的实现速度比使用 OpenML 的 Darknet 快9倍。

正文

我会先结合脚本片段讲解，再给出该脚本的完整代码，讲解。
先

引库

import numpy as np
import cv2 as cv
import os
import time

参数：

yolo_dir = '/home/hessesummer/github/NTS-Net-my/yolov3'  # YOLO文件路径
weightsPath = os.path.join(yolo_dir, 'yolov3.weights')  # 权重文件
configPath = os.path.join(yolo_dir, 'yolov3.cfg')  # 配置文件
labelsPath = os.path.join(yolo_dir, 'coco.names')  # label名称
imgPath = os.path.join(yolo_dir, 'test.jpg')  # 测试图像
CONFIDENCE = 0.5  # 过滤弱检测的最小概率
THRESHOLD = 0.4  # 非最大值抑制阈值

权重文件、配置文件、label名称的下载地址：

wget https://pjreddie.com/media/files/yolov3.weights
wget https://github.com/pjreddie/darknet/blob/master/cfg/yolov3.cfg
wget https://github.com/pjreddie/darknet/blob/master/data/coco.names

简单来说：

过滤弱检测的最小概率：置信度小于这个值的输出都不要了；
非最大值抑制阈值：允许框框重叠的程度（多框框检测同一个物体），供下面的NMS算法使用，该算法会根据该值将有重叠的框框合并。值为0时，不允许框框重叠。默认值是0.3。

详细来说：

我没查。您自己感兴趣再了解吧。

重头戏1：

# 加载网络、配置权重
net = cv.dnn.readNetFromDarknet(configPath, weightsPath)  ## 利用下载的文件
# print("[INFO] loading YOLO from disk...") ## 可以打印下信息

# 加载图片、转为blob格式、送入网络输入层
img = cv.imread(imgPath)
blobImg = cv.dnn.blobFromImage(img, 1.0/255.0, (416, 416), None, True, False)  ## net需要的输入是blob格式的，用blobFromImage这个函数来转格式
net.setInput(blobImg)  ## 调用setInput函数将图片送入输入层

# 获取网络输出层信息（所有输出层的名字），设定并前向传播
outInfo = net.getUnconnectedOutLayersNames()  ## 前面的yolov3架构也讲了，yolo在每个scale都有输出，outInfo是每个scale的名字信息，供net.forward使用
# start = time.time()
layerOutputs = net.forward(outInfo)  # 得到各个输出层的、各个检测框等信息，是二维结构。
# end = time.time()
# print("[INFO] YOLO took {:.6f} seconds".format(end - start)) ## 可以打印下信息

layerOutputs是二维结构，第0维代表哪个输出层，第1维代表各个检测框。

其他的我都在注释里讲解了。

重头戏2：

# 拿到图片尺寸
(H, W) = img.shape[:2]

供下面使用：

# 过滤layerOutputs
# layerOutputs的第1维的元素内容: [center_x, center_y, width, height, objectness, N-class score data]
# 过滤后的结果放入：
boxes = [] # 所有边界框（各层结果放一起）
confidences = [] # 所有置信度
classIDs = [] # 所有分类ID

# # 1）过滤掉置信度低的框框
for out in layerOutputs:  # 各个输出层
    for detection in out:  # 各个框框
        # 拿到置信度
        scores = detection[5:]  # 各个类别的置信度
        classID = np.argmax(scores)  # 最高置信度的id即为分类id
        confidence = scores[classID]  # 拿到置信度

        # 根据置信度筛查
        if confidence > CONFIDENCE:
            box = detection[0:4] * np.array([W, H, W, H])  # 将边界框放会图片尺寸
            (centerX, centerY, width, height) = box.astype("int")
            x = int(centerX - (width / 2))
            y = int(centerY - (height / 2))
            boxes.append([x, y, int(width), int(height)])
            confidences.append(float(confidence))
            classIDs.append(classID)

# # 2）应用非最大值抑制(non-maxima suppression，nms)进一步筛掉
idxs = cv.dnn.NMSBoxes(boxes, confidences, CONFIDENCE, THRESHOLD) # boxes中，保留的box的索引index存入idxs

这里的NMS算法就是前面提到的NMS算法。

应用检测结果，这里是画出框框。

# 得到labels列表
with open(labelsPath, 'rt') as f:
    labels = f.read().rstrip('\n').split('\n')

供下面使用：

# 应用检测结果
np.random.seed(42)
COLORS = np.random.randint(0, 255, size=(len(labels), 3), dtype="uint8")  # 框框显示颜色，每一类有不同的颜色，每种颜色都是由RGB三个值组成的，所以size为(len(labels), 3)
if len(idxs) > 0:
    for i in idxs.flatten(): # indxs是二维的，第0维是输出层，所以这里把它展平成1维
        (x, y) = (boxes[i][0], boxes[i][1])
        (w, h) = (boxes[i][2], boxes[i][3])

        color = [int(c) for c in COLORS[classIDs[i]]]
        cv.rectangle(img, (x, y), (x+w, y+h), color, 2)  # 线条粗细为2px
        text = "{}: {:.4f}".format(labels[classIDs[i]], confidences[i])
        cv.putText(img, text, (x, y-5), cv.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)  # cv.FONT_HERSHEY_SIMPLEX字体风格、0.5字体大小、粗细2px
cv.imshow('目标检测结果', img)
cv.waitKey(0)

第一部分讲解结束，下面放完整代码：
再

import numpy as np
import cv2 as cv
import os
import time

yolo_dir = '/home/hessesummer/github/NTS-Net-my/yolov3'  # YOLO文件路径
weightsPath = os.path.join(yolo_dir, 'yolov3.weights')  # 权重文件
configPath = os.path.join(yolo_dir, 'yolov3.cfg')  # 配置文件
labelsPath = os.path.join(yolo_dir, 'coco.names')  # label名称
imgPath = os.path.join(yolo_dir, 'test.jpg')  # 测试图像
CONFIDENCE = 0.5  # 过滤弱检测的最小概率
THRESHOLD = 0.4  # 非最大值抑制阈值

# 加载网络、配置权重
net = cv.dnn.readNetFromDarknet(configPath, weightsPath)  # #  利用下载的文件
print("[INFO] loading YOLO from disk...")  # # 可以打印下信息

# 加载图片、转为blob格式、送入网络输入层
img = cv.imread(imgPath)
blobImg = cv.dnn.blobFromImage(img, 1.0/255.0, (416, 416), None, True, False)   # # net需要的输入是blob格式的，用blobFromImage这个函数来转格式
net.setInput(blobImg)  # # 调用setInput函数将图片送入输入层

# 获取网络输出层信息（所有输出层的名字），设定并前向传播
outInfo = net.getUnconnectedOutLayersNames()  # # 前面的yolov3架构也讲了，yolo在每个scale都有输出，outInfo是每个scale的名字信息，供net.forward使用
start = time.time()
layerOutputs = net.forward(outInfo)  # 得到各个输出层的、各个检测框等信息，是二维结构。
end = time.time()
print("[INFO] YOLO took {:.6f} seconds".format(end - start))  # # 可以打印下信息

# 拿到图片尺寸
(H, W) = img.shape[:2]
# 过滤layerOutputs
# layerOutputs的第1维的元素内容: [center_x, center_y, width, height, objectness, N-class score data]
# 过滤后的结果放入：
boxes = [] # 所有边界框（各层结果放一起）
confidences = [] # 所有置信度
classIDs = [] # 所有分类ID

# # 1）过滤掉置信度低的框框
for out in layerOutputs:  # 各个输出层
    for detection in out:  # 各个框框
        # 拿到置信度
        scores = detection[5:]  # 各个类别的置信度
        classID = np.argmax(scores)  # 最高置信度的id即为分类id
        confidence = scores[classID]  # 拿到置信度

        # 根据置信度筛查
        if confidence > CONFIDENCE:
            box = detection[0:4] * np.array([W, H, W, H])  # 将边界框放会图片尺寸
            (centerX, centerY, width, height) = box.astype("int")
            x = int(centerX - (width / 2))
            y = int(centerY - (height / 2))
            boxes.append([x, y, int(width), int(height)])
            confidences.append(float(confidence))
            classIDs.append(classID)

# # 2）应用非最大值抑制(non-maxima suppression，nms)进一步筛掉
idxs = cv.dnn.NMSBoxes(boxes, confidences, CONFIDENCE, THRESHOLD) # boxes中，保留的box的索引index存入idxs
# 得到labels列表
with open(labelsPath, 'rt') as f:
    labels = f.read().rstrip('\n').split('\n')
# 应用检测结果
np.random.seed(42)
COLORS = np.random.randint(0, 255, size=(len(labels), 3), dtype="uint8")  # 框框显示颜色，每一类有不同的颜色，每种颜色都是由RGB三个值组成的，所以size为(len(labels), 3)
if len(idxs) > 0:
    for i in idxs.flatten():  # indxs是二维的，第0维是输出层，所以这里把它展平成1维
        (x, y) = (boxes[i][0], boxes[i][1])
        (w, h) = (boxes[i][2], boxes[i][3])

        color = [int(c) for c in COLORS[classIDs[i]]]
        cv.rectangle(img, (x, y), (x+w, y+h), color, 2)  # 线条粗细为2px
        text = "{}: {:.4f}".format(labels[classIDs[i]], confidences[i])
        cv.putText(img, text, (x, y-5), cv.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)  # cv.FONT_HERSHEY_SIMPLEX字体风格、0.5字体大小、粗细2px
cv.imshow('detected image', img)
cv.waitKey(0)

结果：

到此结束～

写博客真累，花太多时间了哎～
标签: opencv, yolov3, 目标检测
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
6
0
« 上一篇： ubuntu使用scrcpy手机投屏-免费神器scrcpy【介绍、安装、使用】
» 下一篇： 【Q&A】pytorch中的worker如何工作的
posted @ 2019-08-11 18:03  小塞  阅读(26291)  评论(3)  编辑  收藏  举报



10


ubuntu使用scrcpy手机投屏-免费神器scrcpy【介绍、安装、使用】

目录

    scrcpy的介绍、安装、使用
        scrcpy介绍
        scrcpy安装
            步骤1：启动adb服务
                第一次，安装并配置adb服务
                第一次以后，开启adb服务
            步骤2：snap方式安装scrcpy
        scrcpy常用方法
            检查设备连接
            开始投屏
            结束投屏
            回到HOME/返回/进入后台
            全屏/回到合适尺寸
            展开通知栏/折叠通知栏
            安卓设备与电脑相互复制粘贴
            安装apk文件
            其他...
            参考资料


欢迎转载，转载请说明出处

（上图是我最常见的使用场景：搜索微信公众号的文章，再复制链接，粘贴连接到PC浏览器中看、做笔记）
scrcpy的介绍、安装、使用
scrcpy介绍

scrcpy是screen copy的简写，是一个免费的开源软件，通过命令行和快捷键执行，实现安卓设备向电脑的高清投屏。我个人体验，感觉操作方便简洁，相当nice！！！

我使用过vysor，但是免费版的各种功能都受限，分辨率低而且不能调，用着很不爽...付费版，要70刀...破解版都比较旧，我试过比较新的2.1.4的破解版，破解者只提供了覆盖文件，把它覆盖在最新的2.1.7，运行失败，但是又找不到2.1.4的原安装包（相信我，真的找不到，google了好几个小时），所以破解版也凉凉（除非我用别的低版本的破解版）

google的时候发现一个geak网站里面有人说scrcpy，github已经有一万多star了，看到它的issue也提的多解决得也多，就决定干脆用这个啦～果然不是所望啊～～

发现国内的使用者还很少，因此贡献一篇博文，扩大一下scrcpy在国内的影响力，表达我对它的喜爱哈哈哈

github地址：https://github.com/Genymobile/scrcpy

具体特点：

功能：

    支持usb连接或wifi连接
    支持录屏
    支持鼠标键盘交互
    支持apk拖放安装
    支持文件上传
    支持多设备同时投屏

性能：

    高清，且尺寸、分辨率可调整
    低延迟

scrcpy安装

以下安装方式是针对usb连接方式的，无线连接由于没有用过，所以后续再补充。
步骤1：启动adb服务

usb连接方式就是：

安卓设备：

    usb线连接
    设置：usb偏好为“文件传输”（从正常使用scrcpy的角度来看，也可以不设置。但是设置完之后，手机和电脑的文件互传就会变得相当方便（用文件管理器剪切粘贴即可），我每次都会用～）
    设置：开启开发者模式，开启usb调试

电脑：

    启动adb服务

安卓设备那里没什么好说的，操作很简单；所以这里只谈“开启adb服务”。

“开启adb服务”包括第一次安装并配置并开启、第一次以后的直接开启。

无论是第一次，还是第一次以后，都首先，把安卓设备那三步操作完成。
第一次，安装并配置adb服务

    安装adb，查看自己的安卓设备

    sudo apt-get install android-tools-adb
    adb start-server
    lsusb

    输出以下信息：

    找到自己的安卓设备哪一行，2a70、9011在下面会用到。

    创建设备文件：

    下面命令中的名称“90-android”是自定义的，我的这个代表安卓9.0的意思。

    echo 0x12d1 > ~/.android/adb_usb.ini
    touch /etc/udev/rules.d/90-android.rules
    gedit /etc/udev/rules.d/90-android.rules

    将以下内容写入刚刚创建的文件，注意，下面的2a70、9011要改成自己的安卓设备的id（见上）：

        SUBSYSTEM"usb", ATTRS{idVendor}"2a70", ATTRS{idProduct}=="9011", MODE="0666"

    更改文件权限：

    chmod 666 /etc/udev/rules.d/90-android.rules

    重启adb服务

service udev restart
adb kill-server
adb start-server
```

执行以下命令，如有设备，则说明adb配置成功了：

```bash
adb devices
```

第一次以后，开启adb服务

adb devices
adb start-server
adb devices

其实只要之前有开启过，就会一直（包括重启后）保持开启状态，除非手动关闭。
在这里记录这条命令是为了，以后在不小心关了adb服务时，重新开启它。
步骤2：snap方式安装scrcpy

官方提供的安装方式有：自己编译、snap包、AUR包（for Arch Linux）、Ebuild。

snap包的安装方式又有很多种（网页下载、终端snap命令等等），不在本文讨论范围内，这里只提供一种离线的安装方式。

我已经把snap包（截止到目前的最新版v1.9）下载好了，地址：链接: https://pan.baidu.com/s/1x9SgptII-4KOYW-vPuzMHw 密码: 6vdf

下载完成后到目标目录执行命令：

sudo snap install scrcpy.snap --dangerous

scrcpy常用方法

注意，以下命令都是在终端中输入的、快捷键都是在聚焦于安卓设备窗口时键入的。
检查设备连接

首先，将安卓设备通过usb连接好（见上，三部曲），将电脑上的adb服务开启（见上）

scrcpy.adb devices

开始投屏

首先，检查设备有没有连接好（见上）。然后输入如下命令打开scrcpy。

scrcpy

其实不检查也可以，一般情况下adb服务都是打开的。
结束投屏

关闭安卓设备窗口即可
回到HOME/返回/进入后台

分别是：鼠标中键、鼠标右键、Ctrl + s
全屏/回到合适尺寸

Ctrl + f、Ctrl + x
展开通知栏/折叠通知栏

Ctrl + n、Ctrl + Shift + n
安卓设备与电脑相互复制粘贴

在安卓设备复制后，粘贴到电脑上，粘贴的快捷键是：
在安卓设备上正常复制，随后再按Ctrl + c，在电脑上粘贴即可。

在电脑复制后，粘贴到安卓设备上，粘贴的快捷键是：
在电脑上正常复制后，在安卓设备上粘贴前，按Ctrl + Shift + v，然后再在安卓设备上正常粘贴。
安装apk文件

直接拖动一个apk文件到安卓设备窗口即可完成安装，终端将打印出相应信息
其他...

至于文件互传功能，我觉得直接在电脑上通过文件资源管理器更方便；
至于录屏功能，我觉得手机录屏工具更方便；
随着后续使用的增多，我会继续补充此文。
参考资料

    https://github.com/Genymobile/scrcpy
    https://www.linuxuprising.com/2019/03/install-scrcpy-on-linux-from-snap.html
    https://www.linuxuprising.com/2019/03/control-android-devices-from-your.html
    https://blog.csdn.net/ppggxn/article/details/81709350

标签: 投屏, scrcpy
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
3
0
« 上一篇： 【从踩坑到教程】win10下ubuntu18.04双系统UEFI模式安装、Nvidia驱动安装
» 下一篇： 【教程】opencv-python+yolov3实现目标检测
posted @ 2019-07-17 12:38  小塞  阅读(14240)  评论(3)  编辑  收藏  举报



11


【从踩坑到教程】win10下ubuntu18.04双系统UEFI模式安装、Nvidia驱动安装
欢迎转载，转载请说明出处
前言

之前（旧笔记本电脑）装过Ubuntu，按照经验贴一次就成功了，所以我以为不就是装系统嘛，很简单马上就能完事。

结果……这次（新笔记本电脑）花了 4天时间才装好、配好环境，重装次数不下于20次，真的。

原因无他：NVIDIA驱动在ubuntu上的支持不够好的缘故。

旧电脑使用的是intel集成显卡，而新电脑是NVIDIA gtx 1070独立显卡，需要对应的显卡驱动，才能正常使用该显卡。

在显卡驱动没有装好的情况下，会出现各种BUG，包括且不限于（我经历过的）：

    U盘插好后，点击install Ubuntu后，黑屏没反应
    通过某方法解决上述问题后，装好后，重启显示登录页面，卡住了登不了/循环登录（输入密码没登进去又回到登录界面了）
    通过某方法解决上述问题后，进入ubuntu桌面后，点击系统设置，没反应/ctrl+alt+F1进入命令行模式，在命令行模式中又让你循环登录

通过一定trick安装完成ubuntu，紧接着在ubuntu内正确安装显卡驱动，这一切的一切bug才（亲测）烟消云散，从此月朗风清！

以下正文，希望帮助大家以正确姿势、顺利、不浪费时间地初步搭建ubuntu开发环境：
正文
安装Ubuntu 18.04 LST
一、准备工作——明确：u盘作为安装盘 + BIOS使用UEFI模式启动电脑

    Knowledge：什么是UEFI模式？

    先简单提一下BIOS吧，供诸君回忆：

    BIOS是一组程序（输入输出程序、开机自检程序、系统自启动程序等），固化在主板上的一个ROM芯片上。开机后，CPU自动读取BIOS中的代码（汇编语言编写）到内存，开始执行BIOS程序。

    然后就是和UEFI模式相关的内容了：

    BIOS具有两种模式，一个是传统的Legacy模式，一种是新的UEFI模式：

    二者最大的区别在于磁盘分区架构 ，前者使用主引导分区记录（MBR）架构（感兴趣的同学请自行查阅其具体实现），该架构对单个磁盘容量的支持仅为2 TB（显然不能满足大型服务器），并且每个磁盘最多有4个主分区（如果主分区的需求大，该架构显然也不能满足）。 而后者使用GPT架构，对单个磁盘容量的支持增大到18 EB（1EB=1024PB、1PB=1024TB），并且每块磁盘最多有 128 个分区。另外，GPT架构的磁盘还具有多余的主要及备份分区表，来提高分区数据结构的完整性。

    Practice：现在来实践一下吧，看一看你的电脑的BIOS支持哪些模式？

    方式一：百度经验：如何查看电脑硬盘是gpt分区还是MBR分区

    如果结果是gpt分区，那么你的BIOS就使用的是UEFI模式。一般来说，预装了win8/win10的电脑使用的都是gpt分区，预装了win7的一般是mbr分区。

    方式二：开机后进入BIOS界面查看——由于不同的机型BIOS界面长得千差万别，不好描述，而且方式一已经足够好了，所以这里就不提了。但是，是一定能看到的。

再次请君注意，由于本人条件、精力限制，本教程仅针对BIOS为UEFI模式的电脑。

 
二、准备U盘——将ios镜像文件写入磁盘映像

    我尝试过很多工具：软碟通、rufus、etcher、老毛桃。

    rufus我忘记了...etcher会把u盘容量变小，需要一定方法在u盘使用过后恢复u盘；老毛桃貌似使用了一个PE系统，操作复杂度高，不推荐。

    软碟通的操作简单，关键是最后用它成功了……所以建议使用软碟通。

1. 在ubuntu官网下载对应版本的 Ubuntu 18.04.2 LTS Desktop image（ubuntu桌面版本的ios镜像文件）

2. 使用软碟通将ios镜像文件写入磁盘映像：见该百度经验贴

    Tips:

    1. 这个百度经验贴已经足够好，本人就使用了这个方法（写入方式设为了hdd+）。

    2. 在重装系统时，建议再重新执行一次该步骤，而不要用已经用过一次的U盘。实测，确实会出现一些第一次没有出现过的问题，还不知道这些问题是哪里冒出的，明明操作完全相同……

 
三、为ubuntu准备“未分配/空闲的空间”、考虑ubuntu使用多少空间+怎样分配它们的问题

    虽然在ubuntu安装时，有“ubuntu与windows共存的选项”，但是听说这样不方便管理ubuntu，而且会出现各种BUG。所以我使用的是为ubuntu系统、该系统下 下载使用的文件，准备另外的独立的空间。

    因此需要在安装ubuntu之前，将磁盘上的一部分空间设为“未分配”。这个操作可以在windows下完成（也可以通过一个PE系统完成），并且有多种方式都可以完成，下面将介绍一种方便简单的方式。

1. 考虑ubuntu使用多少空间、怎样分配它们的问题

    这个问题其实水蛮深的，需要知道Linux系统的目录树结构、目录树的挂载等基础知识，还需要知道自己将要在ubuntu上使用哪些软件，这些软件的大小、默认安装在什么位置（一般使用默认位置，不然有时出了bug上网找解决方案时得再自行修改些东西，有些麻烦）

    在这里不再将这些知识点展开了，而是直接说下我的实操方案，供诸君参考：

        配置：16G内存，一块512G的SSD
        需求：平时基本不使用windows，而是使用ubuntu进行深度学习学习、工作。需要在ubuntu上安装CUDA+CUDNN（默认安装在/usr）、Anaconda3（默认安装在/home）、Pytorch、TensorFlow、Pycharm，还有自己的project（想要放在/home下）。
        综上：
            290G给win10，216G给ubuntu（剩余空间被系统分区等占有）：
            8G给交换空间
            20G给/
            60G给/usr
            余下的空间128G给/home

2. 将所需空间设为“未分配”：方法见该百度经验贴，注意执行到第5步即可。

 
四、安装ubuntu——11个关键步骤

1. 关机，插好U盘

2. 开机，立即进入BIOS：

    保持UEFI选项不变（不要设为Legacy）
    找到security boot设置项，设为disabled
    在启动顺序中，将USB硬盘设为第一位
    保存退出BIOS

    这里不、也无法详述了，因为不同机型进入BIOS的方式不同、BIOS界面差距也很大，还请诸君耐心寻找这些选项并修改。

    security boot设置项设为disabled

    我看到别人的博客有写到遇到，在security boot设为启动时，BIOS将不会经过ubuntu的grub，而是自动执行windows manager。而且ubuntu还会有其他的各种BUG。

3. 保持U盘插入状态，开机后将见到黑色的安装界面。

4. [※重要※] 将光标移动到第二行“Install Ubuntu”，按e键，进入grub配置界面，在倒数第二行，将“quiet splash --” 替换为 “quiet splash $vt_handoff acpi_osi=linux nomodeset”，按F10保存修改并进入安装界面。见下图。

 

进入ubuntu临时系统，默认打开了安装程序，一步一步执行：

5. [※重要※] 选择“最小安装”，其他选项包括“安装时下载更新”、“安装第三方软件”，均不要勾选，不仅会拖慢速度，而且由于显卡驱动还没有装好，安装好的第三方软件还可能会让装好的ubuntu卡住（没错，我就掉坑了…）

6. [※重要※] 选择安装类型时，点击“其他选项”

7. 在分区界面时时发现窗口有部分被遮挡，按alt+F7，拖动鼠标，即可在窗口的任意位置（不仅标题）拖动该窗口。

8. 选中设备状态为“空闲”的一行，点击其左下的“＋”，按照事先自己的约定填写选项即可。另需注意：

对于交换空间，“新分区位置”都保持默认，分区类型填为“主分区”，“用于”改为交换空间；

对于/、/usr、/home，“新分区位置”都保持默认，分区类型填为“逻辑分区”，“用于”保持默认；

 [※重要※] "安装启动引导器的设备“：选择 windows manager即可，因为ubuntu 18.04支持UEFI模式启动。而不需要挂载/boot。

9. [※重要※] 设置用户时，点选“自动登录”，否则会遇到安装完成后登录不进去的问题，其实还是显卡驱动的问题。

10. 安装完成，点击“立即重启”，注意出现让拔U盘的提示后，快速把U盘拔掉

11. 重启时进入BIOS，把启动顺序改为UEFI硬盘启动优先，并且把ubuntu设为优先（较windows manager）

 
安装Nvidia驱动

进入Ubuntu后切记！不要兴奋得太早，东点西点电脑卡住了又得重启……
一、思考选择合适的驱动版本

所谓合适，是指支持你的GPU型号、支持你将要使用的cuda版本、cudnn版本、pytorch版本、tensorflow版本。

不要急，自底向上，一步步分析：

1. 进入Nvidia官网，输入你的GPU、操作系统信息，在结果列表中查看支持你GPU的驱动有那些，驱动版本在第二行小字部分有写；

    我的搜索结果：

　

 

2. 到CUDA官网查看CUDA版本和驱动版本的对照图，截图：

    

 

3. 进入cuDNN版本页面，查看与CUDA版本对应的cuDNN版本，网页截图：

    

 

4. 进入pytorch官网，可以看到pytorch支持CUDA9.0及以上。网页截图：

    

 

5. 进入tensorflow官网，可以看到tensorflow版本与cuda、cudnn的版本对应关系。网页截图“

    

 

6. 综上，可以确定出自己的版本对照表格，以我为例：
可用驱动版本   	

CUDA版本  
	cuDNN版本 	pytorch版本  	tensorflow版本             
410.66以上均可 	10.0 	7.4.0 	1.1 	tensorflow_gpu-1.13.0

 

 

 

 所以我决定安装Nvidia 410版本的驱动。
 
二、安装驱动

    网上有很多种安装方式

    1. 添加NVIDIA显卡驱动的源，apt-get安装

    2. 官网下载驱动文件，然后本地安装

    3. 安装CUDA的时候，自动安装相应的显卡驱动

我最后用第三种方式成功安装了，参考资料：How do I install NVIDIA and CUDA drivers into Ubuntu?

1. 移除已存在的CUDA PPA源和安装过的nvidia-cuda-toolkit

sudo rm /etc/apt/sources.list.d/cuda*
sudo apt remove --autoremove nvidia-cuda-toolkit

2. 移除之前存在的Nvidia驱动

sudo apt remove --autoremove nvidia-*

3. 更新源

sudo apt update

4. 添加graphics-drivers ppa

sudo add-apt-repository ppa:graphics-drivers/ppa

5. 安装key

sudo apt-key adv --fetch-keys  http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub

6. 添加仓库

sudo bash -c 'echo "deb http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64 /" > /etc/apt/sources.list.d/cuda.list'
sudo bash -c 'echo "deb http://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64 /" > /etc/apt/sources.list.d/cuda_learn.list'

7. 再次更新

sudo apt update

8. 安装CUDA。在安装的同时自动安装了Nvidia驱动。

sudo apt install cuda-10-0

如果提示依赖缺失，根据提示，执行：

sudo apt update
sudo apt install cuda-10-0 --fix-missing
sudo apt update

9. 安装CUDNN

sudo apt install libcudnn7

10. 将CUDA加入环境变量

gedit ~/.profile

把以下内容复制到文件末尾

# set PATH for cuda 10.0 installation
if [ -d "/usr/local/cuda-10.0/bin/" ]; then
    export PATH=/usr/local/cuda-10.0/bin${PATH:+:${PATH}}
    export LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}
fi

11. 安装nvidia-cuda-toolkit

sudo apt install nvidia-cuda-toolkit

如果提示依赖缺失，同样地，执行：

sudo apt update
sudo apt install nvidia-cuda-toolkit --fix-missing
sudo apt update

12. 重启

13. 检查是否安装成功

1）检查CUDA版本

nvcc --version

显示如下信息：

nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2017 NVIDIA Corporation
Built on Fri_Nov__3_21:07:56_CDT_2017
Cuda compilation tools, release 9.1, V9.1.85

 

2）检查CUDNN版本

/sbin/ldconfig -N -v $(sed 's/:/ /' <<< $LD_LIBRARY_PATH) 2>/dev/null | grep libcudnn

显示如下信息：

    libcudnn.so.7 -> libcudnn.so.7.6.1

 

3）检查NVIDIA驱动：

nvidia-smi

显示如下信息：
复制代码

Tue Jul 16 12:39:49 2019       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 418.67       Driver Version: 418.67       CUDA Version: 10.1     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  GeForce GTX 107...  On   | 00000000:01:00.0 Off |                  N/A |
| N/A   52C    P5     6W /  N/A |    651MiB /  8119MiB |      0%      Default |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID   Type   Process name                             Usage      |
|=============================================================================|
|    0      1113      G   /usr/lib/xorg/Xorg                           216MiB |
|    0      1456      G   /usr/bin/gnome-shell                         266MiB |
|    0      2550      G   ...quest-channel-token=2425377841825622846   133MiB |
|    0     25058      G   ...er/下载/WizNote-2.7.5-x86_64.AppImage    29MiB |
+-----------------------------------------------------------------------------+

复制代码

 

看到这里你已经完美地完成啦～本教程也到此为止～

 
标签: ubuntu安装, nvidia驱动安装
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
1
0
« 上一篇： Python引用与目录结构
» 下一篇： ubuntu使用scrcpy手机投屏-免费神器scrcpy【介绍、安装、使用】
posted @ 2019-07-16 12:46  小塞  阅读(3703)  评论(1)  编辑  收藏  举报


12


Python引用与目录结构

目录

    Python引用与目录结构
        模块的概念
        包的概念
        引用时搜索模块的顺序
        python工程常用目录结构
        参考资料


哎。差点找不到之前写的这篇笔记。

Python引用与目录结构
模块的概念

模块即单个.py文件。
模块名即文件名。

引用模块：

    只在第一次引用时执行、且执行一次。

    引用及使用方法：

    # 仅引模块
    import module
    m1.fun() ##使用其内变量/函数，必须使用"模块名."。否则报错

    # 引模块的特定变量/函数
    from module import fun
    fun()　##不必使用"模块名."

模块也是对象，具有一个内置属性__name__。该属性有两种取值：模块名、__main__。

    举例说明取值问题：当在A文件中引入B模块，A文件的__name__取值为__main__，B模块的__name__取值为模块名。

    __name__的使用场景：在import模块时，默认情况下，模块的所有语句都会被执行一次。如果希望模块中有某些语句，在import时避免执行，可以：

    if __name__ == 'main':
        ## 这里的语句将在import时避免执行
        ## 因为import时，条件为假

包的概念

包即一个文件夹。
包含了__init__.py和一系列.py文件。包名即文件夹名。

__init__.py是为了避免将文件夹名当作普通的字符串，其内容可以为空，一般用来进行包的某些初始化工作或者设置__all__值，用以暴露该包的 API。
引用时搜索模块的顺序

    当前文件所在目录
    环境变量PYTHONPATH（包含python带的模块、自己安装的模块），可以通过bash或sys.path修改

python工程常用目录结构

    方式一

    -- src
        |-- mod1.py（被引用的模块）
        `-- test1.py（主程序）

    在test1.py中直接import mod1即可。

    方式二：

    -- src
        |-- mod1.py（被引用的模块1）
        |-- pkg
        |	|-- __init__.py（必须有）
        |   `-- mod2.py（被引用的模块2）
        `-- test1.py（主程序）

    在test1.py中import mod1

    在test1.py中from pkg import mod2

    方式三：

    -- src
        |-- mod1.py
        |-- pkg
        |	|-- __init__.py（必须有）
        |   `-- mod2.py
        |-- sub
        |   `-- test2.py
        `-- test1.py

    在test1.py中import mod1

    在test1.py中from pkg import mod2

    在test2.py中

    import sys
    sys.path.append("..") ## 临时加入父目录
    ## 然后就可以正常地：
    import mod1
    from pkg import mod2

    在test1.py中from pkg import mod2

参考资料
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： argparse入门
» 下一篇： 【从踩坑到教程】win10下ubuntu18.04双系统UEFI模式安装、Nvidia驱动安装
posted @ 2019-07-08 15:57  小塞  阅读(1912)  评论(0)  编辑  收藏  举报



13


C++正则表达式

目录

    C++正则
        总述
        ECMAScript支持的正则
            具有特殊意义的元字符
            量词元字符
        C++支持的正则
        C++使用正则
            匹配与否
            捕获
                更高级的捕捉
            捕捉的同时生成新串
        参考资料

转载请说明出处。
C++正则
总述

正则是一种规则，它用来匹配（进而捕获、替换）字符串。这种规则需要“模式”、“字符串”这两样东西，“模式”根据正则规则，来处理“字符串”。

这种规则被许多语言支持，C++11以后才支持正则。

C++11支持的正则和其他语言支持的正则有区别，本篇记录的目的不在于讲解正则，也不在于阐述C++11支持的正则详细是什么，而是只记下常见的、够用的正则规则（以供速查，应有不严谨之处）及使用用法。
ECMAScript支持的正则

正则由元字符和普通字符组成。普通字符就代表它原本的含义；元字符的意义不同于该字符本来的含义，而是有特殊的意义和功能。

根据其意义功能划分，可将元字符划分为：
具有特殊意义的元字符

\：\字符能够改变字符原本的含义

^：^字符指示字符串的头，且要求字符串以字符开头，不占位。\^表示一个真正的^符号。

$：$字符指示字符串的尾，且要求字符串以字符结尾，不占位。\$表示一个真正的$符号。

()：分组，大正则中包含小正则。可以改变默认的优先级。在模式中可以使用\1来表示第一组已然捕获到的东西。

\b：指示字符串的边界（头/尾/空格左/空格右），字符\b要求边界的左边是字符，\b字符要求边界的右边是字符。

.：表示一个除了\n以外的任意一个字符。\.表示一个真正的.符号。

|：字符串1|字符串2表示一个字符串，该字符串是字符串1、字符串2中的一个。|在正则中的优先级比较混乱，所以建议加上足够多的括号来分组。

[]：[字符1字符2字符3...]表示一个字符，该字符是字符1、字符2、字符3……中的某一个。中括号中出现的所有字符都是代表本身意思的字符（没有特殊含义），如[.]只能匹配.符号，而不能匹配任意符号。

[^字符1字符2字符3...]表示一个字符，该字符不是字符1、字符2、字符3……中的任何一个

[a-z]表示一个字符，该字符是a、b、c……z中的某一个

[^a-z]表示一个字符，该字符不是a、b、c……z中的任何一个

\w：表示一个字符，该字符是数字、字母、下划线中的某一个。等价于[(0-9)(a-z)(A-Z)(_)]

\W：表示一个字符，该字符不是数字、字母、下划线中的任何一个。等价于[]

\d表示一个字符，该字符是0、1、2……9中的某一个

\D表示一个字符，该字符不是0、1、2……9中的任何一个

\s表示一个字符，该字符是空白符（空格、制表符、换页符）2、代表出现次数的
量词元字符

*：字符*要求字符出现0到多次

+：字符+要求字符出现1到多次

?：字符?要求字符出现0次或1次

{n}：字符{n}要求字符出现n次

{n,}：字符{n,}要求字符出现n到多次

{n,m}：字符{n,m}要求字符出现n到m次、
C++支持的正则

C++可以支持ECMAScript支持的正则，也可以支持grep支持的正则等等。

由于我本人较熟悉ECMAScript支持的正则，且C++默认支持的即是它，所以我接下来讲的也是这种正则。

首先要举一个例子解释一下，

/**在ECMAScript中写一个匹配11位电话号码的正则模式是这样写的**/
var r = /\d{1, 11}/;
/**在C++中写一个匹配11位电话号码的正则模式是这样写的**/
regex r("\\d{1, 11}")

看似不一样，其实是一样的，因为传递给regex构造函数的参数是一个字符串，该字符串被C++编译器解析时，将\\解释为真正的\（由于C++中的字符\是转义字符），解析出来的\和紧随其后的d组合，形成了真正的\d，表示一个数字字符。

所以含有\的元字符，在C++定义时，都要写成\\。
C++使用正则
匹配与否

头文件<regex>中的regex_match和regex_search均可以进行匹配，返回一个布尔类型，匹配成功为true，匹配失败为false。

不同点：前者要求完全匹配，后者要求子串匹配即可；

下面以regex_match为例，regex_search的写法与之相同，故不赘述。

string str = "hhh233";
regex r("[a-z0-9]+");

// 用法一
bool flag = regex_match(str,r);
// 用法二
bool flag = regex_match(str,regex("\\d+"));
// 用法三
bool flag = regex_match(str.begin()+7,str.end(),regex("\\d+"));

捕获

捕获就是先匹配，然后将匹配结果存储下来。捕获同样是使用上面介绍的那两个函数，仍然区分为整串匹配和子串匹配。

捕获的步骤：

    模式中一般要有分组（因为捕捉的正是分组匹配的结果）
    定义一个STL容器smatch，用来保存捕捉的结果
    使用reg_search函数匹配，用smatch的实例存储匹配的结果，即完成捕捉。
    使用m.size()，查看捕捉到的个数；使用m.str(i)，查看捕捉到的字符串；【注意：m.str(0)一定是整个正则匹配到的部分，m.str(1)及以后才是分组捕获的结果】
    m.prefix().str()获取整个匹配之前的字符串；m.suffix().str()获取整个匹配之后的字符串

代码：

#include <bits/stdc++.h>
using namespace std;
int main()
{
    string str;
    while(true){
        cin >> str;
        regex e("([[:w:]]+)@([[:w:]]+)\.com");
        smatch m;
        bool found = regex_search(str, m, e);
        if(found)
        {
            cout << "m.size() " << m.size() << endl;
            for(int i=0; i<m.size(); ++i){
                cout << "m.str(" << i << "): " << m.str(i) << endl;
            }
            cout << "m.prefix().str(): " << m.prefix().str() << endl;
            cout << "m.suffix().str(): " << m.suffix().str() << endl;
        }
        else cout << "Not Found" << endl;
        return 0;
        
        
    }
}

结果为：

补充：

    获取第i个匹配m.str(i)，还有其他等价写法：m[i].str()、*(m.begin() + i)
    模式其实可以不分组...这样就只有m.str(0)捕捉到整个串，没有m.str(1)其他的了。

更高级的捕捉

由于regex_replace方法只能捕捉到第一个匹配，想要捕捉到每一个匹配，以及匹配内的分组，需要使用另外一种方法：

步骤：

    正则内有分组
    定义迭代器的同时初始化迭代器，使其指向一个smatch实例的数组。
    定义end，标志smatch实例的数组的末尾
    使用迭代器遍历数组

代码：

#include <bits/stdc++.h>
using namespace std;
int main()
{
    string str = "boo@gmail.com  boqian@hotmail.com bo_qian@163.com";
    regex e("([[:w:]]+)@([[:w:]]+)\.com");
    sregex_iterator pos(str.cbegin(), str.cend(), e);
    sregex_iterator end;
    
    for(; pos!=end; ++pos)
    {
        cout << "Matched: " << pos->str(0) << endl;
        cout << "user name: " << pos->str(1) << endl;
        cout << "domain: " << pos->str(2) << endl;
        cout << endl;
    }
    return 0;
}

补充：

    同上，模式中也可以没有分组，这样也就没有pos->str(1)其他的了。

    还有一种更高级的捕捉，能够实现一模一样的功能，只是对捕获的结果的组织顺序不相同，它将所有与第一个分组匹配的结果，放在一个容器内。

    运行如下代码，感受一下：

    #include <bits/stdc++.h>
    using namespace std;
    int main()
    {
        string str = "boo@gmail.com  boqian@hotmail.com bo_qian@163.com";
        regex e("([[:w:]]+)@([[:w:]]+)\.com");
        sregex_token_iterator pos(str.cbegin(), str.cend(), e, 1);// 表示第一个分组，再换成0、2、-1感受一下
        sregex_token_iterator end;
        
        for(; pos!=end; ++pos)
        {
            cout << "Matched: " << pos->str() << endl;
            cout << endl;
        }
        return 0;
    }

捕捉的同时生成新串

regex_replace方法先完成捕捉，得到类似于：

大匹配1：分组1、分组2
大匹配2：分组1、分组2
大匹配3：分组1、分组2
...

所以如下代码：

#include <bits/stdc++.h>
using namespace std;
int main()
{
    string str = "boo@gmail.com  boqian@hotmail.com bo_qian@163.com";
    regex e("([[:w:]]+)@([[:w:]]+)\.com");
    cout << regex_replace(str, e, "$1 is on $2\n", regex_constants::format_no_copy); // 除了捕捉到的组以外，其他的东西均舍弃
    return 0;
}

运行结果：

补充：

    regex_replace除了regex_constants::format_no_copy以外，还有其他flag，如regex_constants::format_first_only表示只取“大匹配1”，而忽略其他。
    flag和flag之间通过|相连接。
    regex_match和regex_search也有自己的flag，如用于忽略英文字母大小写的regex_constants::icase

参考资料

https://www.bilibili.com/video/av7701532/?p=12
https://zh.cppreference.com/w/cpp/regex
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
3
0
« 上一篇： jupyter notebook dead kernel问题解决
» 下一篇： 单周期cpu设计代码解读
posted @ 2019-05-16 14:37  小塞  阅读(12057)  评论(0)  编辑  收藏  举报



14


单周期cpu设计代码解读

目录

    写在前面
    单周期cpu设计代码讲解
        概念回顾
            一、电子计算机的部件
            二、cpu
            三、控制器
            四、数据通路：
        Verilog代码讲解
            shift.v
            scinstmem.v
            scdatamem.v
            sccu_dataflow.v
            mux2x32.v
            mux2x5.v
            mux4x32.v
            dff32.v
            cla32.v
            addsub32.v
            alu.v
            regfile.v
            sccpu_dataflow.v
            sccmop_dataflow.v

写在前面

欢迎转载，转载请说明出处。
单周期cpu设计代码讲解
概念回顾
一、电子计算机的部件

分为：中央处理器（cpu）、内部存储器（Memory）、输入/输出（I/O）设备，以及连接它们的总线（Bus）。下图为图示，注意色块的区分。

二、cpu

又包括控制器（Controller）和数据通路（Data Path）。下图为图示，注意色块区分。

三、控制器

分为主控（Main Control）和局控（Local Control或ALU Control）。将二进制指令输入控制器，生成控制信号，该过程称为译码。控制信号控制数据通路工作。且不同的指定对应不同的控制信号。

下图为在控制器中译码的逻辑示意图：

下图为在控制器中译码的物理示意图：

讲解一下从逻辑图到物理图的转换：

    首先由主控解析op指令，如果发现该指令为“000000”则表示该指令是R指令，输出中间信号R-Type为1，否则为0；如果发现该指令是其他值，则按照逻辑图，为RegDst等信号赋相应的值；
    中间信号R-Type起到二路选择的作用，如图。
    中间信号ALUop，在R-Type为0（选择0路）时，直接通过局控，输出成为ALUctr信号，对应上面逻辑图的最后一行后5列；在R-Type为1时，局控起作用。
    局控解析R指令的func部分，输出对应指令的ALUctr信号。

四、数据通路：

是包括运算器、寄存器组、存储器（高速缓存）、多路选择器等等在内的元件的有结构的组合。如下图所示：

【数据通路各部分的讲解将结合代码完成】
Verilog代码讲解

在代码讲解之前有必要放几张图：

shift.v

/*移位*/
/*输入一个数，返回移位之后的结果*/
/*输入d(待移的数)、sa(移动的位数)、right(移动方向)、arith(空位补全方式)*/
/*输出sh(移位后的结果)*/
module shift (d,sa,right,arith,sh);
input  [31:0]  d;
input  [4:0]     sa;
input  right,arith;
output [31:0] sh;
reg  [31:0] sh;
    
// 组合逻辑
always  @*  begin
	if   (!right)  begin // right为逻辑0时，左移
		sh = d << sa;
	end else  if   (!arith)  begin // right为逻辑1，且arith为逻辑0时，右移、0补空
		sh =  d  >>  sa;
	end else begin // 右移、1补空                     
		sh =  $signed(d)  >>>  sa;
	end
end
endmodule

scinstmem.v

/*从ROM（只读存储器）读数据*/
/*输入目标数据在ROM中的地址a*/
/*输出地址对应的数据inst*/
module scinstmem (a,inst); 
	input [31:0] a; 
	output [31:0] inst; 
    wire [31:0] rom [0:31]; // 定义32个32位的存储器ROM

	// 想ROM中写入一组指令，指令对应的汇编含义见行注释
 	assign  rom[5'h00] = 32'h3c010000; // (00) main: lui r1,0
	assign  rom[5'h01] = 32'h34240050; // (04)      ori r4,r1,80
	assign  rom[5'h02] = 32'h20050004; // (08)      addi r5,r0, 4
	assign  rom[5'h03] = 32'h0c000018; // (0c)call: jal sum
	assign  rom[5'h04] = 32'hac820000; // (10)      sw r2,0(r4)
	assign	rom[5'h05] = 32'h8c890000;	//	(14)		lw	r9,	0(r4)
	assign	rom[5'h06] = 32'h01244022;	//	(18)		sub	r8,	r9.	r4
	assign	rom[5'h07] = 32'h20050003;	//	(lc)		addi	r5,	r0.	3
	assign	rom[5'h08] = 32'h20a5ffff;	//	(20)	loop2:	addi	r5,	r5,	-1
	assign	rom[5'h09] = 32'h34a8ffff;	//	(24)		ori	r8,	r5,	0xffff
	assign	rom[5'h0A] = 32'h39085555;	//	(28)		xori	r8.	r8,	0x5555
	assign	rom[5'h0B] = 32'h2009ffff;	//	(2c)		addi	r9,	rO,	-1
	assign	rom[5'h0C] = 32'h312affff;	//	(30)		andi	rlO,	r9,	0xffff
	assign	rom[5'h0D] = 32'h01493025;	//	(34)		or	r6.	rlO,	r9
	assign	rom[5'h0E] = 32'h01494026;	//	(38)		xor	r8,	rlO,	r9
	assign	rom[5'h0F] = 32'h01463824;	//	(3c)		and	r7,	rlO,	r6
	assign	rom[5'h10] = 32'h10a00001;	//	(40)		beq	r5,	r0,	shift
	assign	rom[5'h11] = 32'h08000008;	//	(44)		j	loop2	
	assign	rom[5'h12] = 32'h2005ffff;	//	(48)	shift:	addi	r5.	r0,	-1
	assign	rom[5'h13] = 32'h000543c0;	//	(4c)		sll	r8.	r5.	15
	assign	rom[5'h14] = 32'h00084400;	//	(50)		sll	r8,	r8,	16
	assign	rom[5'h15] = 32'h00084403;	//	(54)		sra	r8,	r8,	16
	assign	rom[5'h16] = 32'h000843c2;	//	(58)		srl	r8.	r8.	15
	assign	rom[5'h17] = 32'h08000017;	//	(5c)	finish:	j	finish	
	assign	rom[5'h18] = 32'h00004020;	//	(60)	sum:	add	r8,	r0,	r0
	assign	rom[5'h19] = 32'h8c890000;	//	(64)	loop:	lw	r9,	(r4)
	assign	rom[5'h1A] = 32'h20840004;	//	(68)		addi	r4,	r4,	4
	assign	rom[5'h1B] = 32'h01094020;	//	(6c)		add	r8,	r8,	r9
	assign	rom[5'h1C] = 32'h20a5ffff;	//	(70)		addi	r5,	r5,	-1
	assign	rom[5'h1D] = 32'h14a0fffb;	//	(74)		bne	rS,	r0,	loop
	assign	rom[5'h1E] = 32'h00081000;	//	(78)		sll	r2f	r8f	0
	assign	rom[5'h1F] = 32'h03e00008;	//	(7c)		jr	r31		

	// 将地址对应的数据放入inst
	assign inst = rom[a[6:2]];

endmodule

scdatamem.v

/*将数据写入RAM中（随机存取存储器）的指定位置*/
/*输入待写数据datain、目标地址addr；写使能信号we；时钟信号clk、inclk、outclk*/
/*输出将被覆盖的数据dataout*/
module scdatamem (clk,dataout,datain,addr,we,inclk,outclk);
input	[31:0]	datain;
input	[31:0]	addr ;
input		clk, we, inclk, outclk;
output	[31:0]	dataout;
reg [31:0] ram	[0:31]; // 定义32个32位RAM
// 把将被覆盖的数据放入dataout
assign	dataout	=ram[addr[6:2]];
// 时序逻辑，clk的上升沿触发
always @ (posedge clk) begin
	if (we) ram[addr[6:2]] = datain; // 如果写使能信号we为1，将数据写入目标地址
end
// 为RAM赋值，这一步不是必要的，只是欲运行的自定义程序的需要。
integer i;
initial begin
	for (i = 0;i < 32;i = i + 1)
		ram[i] = 0;
	ram[5'h14] = 32'h000000a3;
	ram[5'h15] = 32'h00000027;
	ram[5'h16] = 32'h00000079;
	ram[5'h17] = 32'h00000115;
end
endmodule

sccu_dataflow.v

/*基于MIPS指令集的控制器*/
/*输入指令的op字段、func字段、z信号*/
/*输出wreg,regrt，aluc,pcsource等等控制信号*/
module sccu_dataflow (op,func,z,wmem,wreg,regrt,m2reg,aluc,shift,aluimm,pcsource,jal,sext);
	input [5:0] op,func;
	input z;
	output wreg,regrt,jal,m2reg,shift,aluimm,sext,wmem;
	output [3:0] aluc;
	output [1:0] pcsource;
	
	// 确定内部信号r_type的值
	wire r_type = ~|op;
	
	// 如果r_type为真，根据func，确定是哪一种R型指令
	wire i_add = r_type&func[5]&~func[4]&~func[3]&~func[2]&~func[1]&~func[0];
	wire i_sub = r_type&func[5]&~func[4]&~func[3]&~func[2]&func[1]&~func[0];
	wire i_and = r_type&func[5]&~func[4]&~func[3]&func[2]&~func[1]&~func[0];
	wire i_or = r_type&func[5]&~func[4]&~func[3]&func[2]&~func[1]&func[0];
	wire i_xor = r_type&func[5]&~func[4]&~func[3]&func[2]&func[1]&~func[0];
	wire i_sll = r_type&~func[5]&~func[4]&~func[3]&~func[2]&~func[1]&~func[0];
	wire i_srl = r_type&~func[5]&~func[4]&~func[3]&~func[2]&func[1]&~func[0];
	wire i_sra = r_type&~func[5]&~func[4]&~func[3]&~func[2]&func[1]&func[0];
	wire i_jr = r_type&~func[5]&~func[4]&func[3]&~func[2]&~func[1]&~func[0];
	// 如果r_type为假，根据op，确定是哪一种指令
	wire i_addi = ~op[5]&~op[4]&op[3]&~op[2]&~op[1]&~op[0];
	wire i_andi = ~op[5]&~op[4]&op[3]&op[2]&~op[1]&~op[0];
	wire i_ori = ~op[5]&~op[4]&op[3]&op[2]&~op[1]&op[0];
	wire i_xori = ~op[5]&~op[4]&op[3]&op[2]&op[1]&~op[0];
	wire i_lw = op[5]&~op[4]&~op[3]&~op[2]&op[1]&op[0];
	wire i_sw = op[5]&~op[4]&op[3]&~op[2]&op[1]&op[0];
	wire i_beq = ~op[5]&~op[4]&~op[3]&op[2]&~op[1]&~op[0];
	wire i_bne = ~op[5]&~op[4]&~op[3]&op[2]&~op[1]&op[0];
	wire i_lui = ~op[5]&~op[4]&op[3]&op[2]&op[1]&op[0];
	wire i_j = ~op[5]&~op[4]&~op[3]&~op[2]&op[1]&~op[0];
	wire i_jal = ~op[5]&~op[4]&~op[3]&~op[2]&op[1]&op[0];
	
	// 在确定了指令的情况下，确定控制信号的取值
	assign wreg = i_add|i_sub|i_and|i_or|i_xor|i_sll|i_srl|i_sra|i_addi|i_andi|i_ori|i_xori|i_lw|i_lui|i_jal;
	assign regrt= i_addi|i_andi|i_ori|i_xori|i_lw|i_lui;
	assign jal= i_jal;
	assign m2reg= i_lw;
	assign shift=i_sll|i_srl|i_sra;
	assign aluimm=i_addi|i_andi|i_ori|i_xori|i_lw|i_lui|i_sw;
	assign sext =i_addi|i_lw|i_sw|i_beq|i_bne;
	assign aluc[3]=i_sra;
	assign aluc[2]=i_sub|i_or|i_srl|i_sra|i_ori|i_lui;
	assign aluc[1]=i_xor|i_sll|i_sra|i_xori|i_beq|i_bne|i_lui;
	assign aluc[0]=i_and|i_or|i_sll|i_srl|i_sra|i_andi|i_ori;
	assign wmem = i_sw;
	assign pcsource[1]=i_jr|i_j|i_jal;
	assign pcsource[0]=i_beq&z|i_bne&~z|i_j|i_jal;
endmodule

mux2x32.v

/*32位二路选择器*/
/*输入决定选择哪一路的控制信号s，输入待选择的信号a0、a1*/
/*输出被选择的信号y*/
module mux2x32 (a0,a1,s,y);
	input [31:0] a0,a1;
	input s;
	output [31:0] y;
	assign y = s?a1:a0; // 如果s为1，选择a1，否则选择a0
endmodule

mux2x5.v

/*5位二路选择器*/
/*逻辑同上*/
module mux2x5 (a0,a1,s,y);
	input [4:0] a0,a1;
	input s;
	output [4:0] y;
	assign y = s?a1:a0;
endmodule

mux4x32.v

/*32位四路选择器*/
/*待选择的数是a0~a3，控制信号为s，选择结果为y*/
/*s如何控制，由case语句决定*/
module mux4x32 (a0,a1,a2,a3,s,y);
	input [31:0] a0,a1,a2,a3;
	input [1:0] s;
	output [31:0] y;
	function [31:0] select;
		input [31:0] a0,a1,a2,a3;
		input [1:0] s;

		case (s)
			2'b00: select = a0; //s为00时，选择a0
			2'b01: select = a1;
			2'b10: select = a2;
			2'b11: select = a3;
		endcase
	endfunction
	assign  y = select(a0,a1,a2,a3,s); // y为选择的结果
endmodule

dff32.v

/*将数据送入指定寄存器*/
/*输入待存数据d，待存寄存器q；时钟clk和clrn*/
/*没有输出*/
module dff32(d,clk,clrn,q);
	input [31:0] d;
	input 	clk,clrn;
	output [31:0] q;
	reg  [31:0] q; 
	/*时序逻辑，clk的上升沿降沿触发、clrn的下降沿触发*/
	always @ (negedge clrn or posedge clk)
		// clrn是清零时钟
		if (clrn == 0) begin // 当清零时钟到来时
			q <= 0; // 为q赋值0
		end else begin
			q <= d; // 否则赋值d
		end
endmodule

cla32.v

/*下面所有程序都是为了实现一个东东：32位并行加法器*/
/*从最基本的加法进位模型add实现全加器cla_2，
  逐步集成为4位全加器cla_4、8位的全加器cla_8、
  16位全加器cla_16、32位全加器cla_32,
  最终实现32位并行加法器cla32
*/

/*加数是a、b，和是s*/
/*借位是ci，进位是co*/
module cla32 (a,b,ci,s,co);
	input   [31:0]  a,b;
	input  ci;
	output   [31:0]   s;
	output co;
	wire  g_out, p_out;
	cla_32  cla   (a,b, ci,g_out,p_out, s); // 向下调用
	assign  co  =  g_out| p_out &  ci;
endmodule




module add(a,b,c,g,p,s);
	input a,b,c;
	output g,p,s;
	assign s = a^b^c;
	assign g = a & b;
	assign p = a | b;
endmodule



module g_p  (g,p,c_in,g_out,p_out,c_out);
input  [1:0]  g,p;
input  c_in;
output g_out, p_out, c_out;
assign g_out = g[1]|p[1] & g[0];
assign p_out = p[1]  & p[0];
assign c_out = g[0]   |  p[0]  &  c_in;
endmodule



module cla_2 (a,b,c_in,g_out,p_out,s) ;
input  [1:0]  a,b;
input c_in;
output g_out, p_out;
output  [1:0]  s;
wire  [1:0]  g,p;
wire c_out;
add add0 (a[0],b[0],c_in, g[0],p[0],s[0]);
add add1 (a[1],b[1],c_out, g[1],p[1],s[1]);
g_p g_p0 (g,p,c_in,  g_out,p_out,c_out);
endmodule

module cla_4 (a,b, c_in,g_out,p_out,s);
input  [3:0]  a,b;
input  c_in;
output g_out, p_out;
output  [3:0]  s;
wire  [1:0]  g,p;
wire c_out;
cla_2 cla0 (a[1:0],b[1:0],c_in, g[0],p[0],s[1:0]);
cla_2 clal (a[3:2],b[3:2],c_out,g[1],p[1],s[3:2]);
g_p    g_p0  (g,p,c_in, g_out,p_out,c_out);
endmodule

module  cla_8   (a,b, c_in,g_out,p_out, s);
input   [7:0]  a,b;
input  c_in;
output  g_out, p_out;
output   [7:0]   s;
wire   [1:0]   g,p;
wire  c_out;
cla_4  cla0  (a[3:0],b[3:0],c_in, g[0],p[0],s[3:0]);
cla_4  c1a1  (a[7:4],b[7:4],c_out,g[1],p[1],s[7:4]);
g_p   g_p0  (g,p,c_in,  g_out,p_out,c_out);
endmodule


module cla_16 (a,b, c_in,g_out,p_out, s);
input   [15:0]  a,b;
input  c_in;
output  g_out, p_out;
output   [15:0]  s;
wire  [1:0]  g,p;
wire  c_out;
cla_8  cla0   (a[7:0],b[7:0],c_in,g[0],p[0],s[7:0]);
cla_8  cla1   (a[15:8],b[15:8],c_out,g[1],p[1],s[15:8]);
g_p    g_p0  (g,p,c_in,  g_out,p_out,c_out);
endmodule


module cla_32  (a,b,c_in,g_out,p_out, s);
input  [31:0]  a,b;
input c_in;
output  g_out, p_out;
output  [31:0]  s;
wire  [1:0]  g,p;
wire c_out;
cla_16 c1a0 (a[15:0],b[15:0],c_in,g[0],p[0],s[15:0]);
cla_16 c1a1 (a[31:16],b[31:16],c_out,g[1],p[1],s[31:16]);
g_p    g_p0  (g,p,c_in, g_out,p_out,c_out);
endmodule

addsub32.v

/*32位加减运算模块*/
/*调用32位加法模块*/
/*是加是减，取决于sub的取值*/
module addsub32(a,b,sub,s);
	input [31:0] a,b;
	input  		sub;
	output [31:0] s;
	cla32 as32 (a,b^{32{sub}},sub,s);
endmodule

alu.v

/*alu算数逻辑单元*/
/*输入操作数a、b，操作类型信号aluc*/
/*输出运算结果r；z是？*/
module alu (a,b,aluc,r,z);
input [31:0] a,b; 
// aluc是3位的，每一位都有作用，见下
input [3:0] aluc; 
output  [31:0]  r;  
output z;            
wire  [31:0]  d_and = a & b; // 求和
wire  [31:0] d_or = a | b; // 求或
wire  [31:0] d_xor = a ^ b; // 求异或
wire  [31:0]  d_lui = {b[15:0],16'h0}; // 拼接，低16位补0

wire  [31:0]  d_and_or = aluc[2]? d_or : d_and; // aluc[2]决定 与/或
wire  [31:0]  d_xor_1ui= aluc[2]? d_lui : d_xor;  // aluc[2]决定 异或/拼接

wire  [31:0]  d_as,d_sh; // 加减法结果保存到d_as中；移位结果存入d_sh中
// aluc[2]控制加减法
addsub32 as32  (a,b,aluc[2],d_as); 
// b为待移的数，a[4:0]为移动位数，aluc[2]决定左右移，aluc[3]决定补全方式，结果保存在d_sh中
shift shifter  (b,a[4:0],aluc[2],aluc[3],d_sh) ; 

// 四路选择，aluc[1:0]控制选择哪一路，r为选择结果
mux4x32 se1ect  (d_as,d_and_or, d_xor_1ui, d_sh, aluc[1:0],r);
assign z = ~|r;
endmodule    

regfile.v

/*读寄存器堆、写寄存器堆*/
/*输入将要读取哪一个寄存器rna、rnb；输出读出的内容qa、qb*/
/*输入写使能we、待写入的寄存器wn，待写入的数据d*/
/*输入时钟clk、clrn*/
module regfile  (rna, rnb, d, wn,we, clk, clrn, qa, qb);
input       [4:0]  rna,rnb,wn;
input     [31:0]  d;
input     we, clk, clrn;
output  [31:0]  qa,qb;
reg     [31:0]  register  [1:31];  // 定义32个32位寄存器

// 读寄存器
// 如果指定的是rna，即rna不为0，将rna寄存器中的内容放入qa
assign qa  =   (rna ==  0) ? 0 : register[rna]; 
// 如果指定的是rnb，即rnb不为0，将rnb寄存器中的内容放入qb
assign qb  =   (rnb ==  0) ? 0 : register[rnb];
 

// 写寄存器
// 时序逻辑，clk的上升沿或clrn的下降沿触发
always @(posedge clk or negedge clrn)
begin 
if  (clrn==0) // 当为清空时钟信号时
begin
	integer i;
	for(i=1;i<32;i=i+1)
		register[i] <= 0; // 清空所有寄存器
end 
else  if((wn!=0)&&we) // 当写使能为逻辑1，且wn不是0时
register[wn]  <= d; // 将d写入wn寄存器
end
endmodule

sccpu_dataflow.v

/*cpu*/
/*输入时钟信号clock、是否进行清零的信号resetn*/
/*输入32位指令inst、以及其他值*/
module  sccpu_dataflow(clock, resetn, inst, mem, pc, wmem, alu, data);
input     [31:0]   inst,mem;
input         clock, resetn;
output   [31:0]  pc,alu,data;
 
output wmem;
wire  [31:0] p4 , bpc, npc, adr, ra, alua, alub, res, alu_mem;
wire  [3:0] aluc;
wire  [4:0] reg_dest, wn;
wire  [1:0] pcsource;
wire  zero, wmem, wreg, regrt, m2reg, shift, aluimm, jal, sext;
wire  [31:0]  sa  =  {27'b0,inst[10:6]};
wire  [31:0]  offset  =  {imm[13:0],inst[15:0],2'b00};

/*控制器*/
// 输入inst[31:26]即op字段、inst[5:0]即func字段、0标志位zero
// 输出wmem、wreg等控制信号
sccu_dataflow cu  (inst[31:26] , inst[5:0] , zero, wmem,wreg,regrt,m2reg, aluc, shift, aluimm,pcsource, jal, sext);

/*0拓展或符号拓展*/
wire   e  =  sext  &  inst[15]; // 取出0或者符号 
wire   [15:0]       imm =  {16{e}}; 
wire  [31:0]       immediate  =  {imm,inst[15:0]}; // 拼接、拓展

/*修改PC，使PC指向下一条地址*、
dff32  ip  (npc,clock,resetn,pc); // 将npc（即下一条指令的地址）写入寄存器pc

/*计算下地址*/
// 四路选择器的0路
cla32  pcplus4   (pc,32'h4,1'b0,p4); // pc和32位十六进制4相加，再加上进位0，结果放入p4
// 四路选择器的1路
cla32  br_adr     (p4,offset,1'b0, adr); // p4和拓展后的imm相加，再加上进位0，结果放入adr
// 四路选择器的3路
wire  [31:0]        jpc =  {p4[31:28],inst[25:0],2'b00}; // 如图

/*二路选择器*/
// ③号。在ra即q1、sa之间选择，控制信号是shift，选择结果为alua
mux2x32  alu_a  (ra,sa,shift,alua);
// ④号。在data即q2、immediate之间选择，控制信号是aluimm，选择结果为alub
mux2x32  alu_b  (data, immediate,aluimm, alub);
// ⑤号。在alu即r、mem即do之间选择，控制信号是m2reg,选择结果为alu_mem
mux2x32  result   (alu,mem,m2reg,alu_mem);
// ②号。在alu_mem、p4之间选择，控制信号是jal即call，选择结构是res
mux2x32  link (alu_mem,p4,jal,res);
// ①号。在inst[15:11]即rd，inst[20: 16]即rt之间选择，控制信号是regrt，选择结果是reg_dest
mux2x5  reg_wn   (inst[15:11], inst[20: 16] , regrt, reg_dest);
// 对应图中的①号后面的f器件（不知道做什么的...）
assign wn = reg_dest   |   {5{jal}}; 

/*四路选择器，计算下地址*/
// 在p4、adr即addr、ra即q1、jpc即p4+immidiate<<2，之间选择，控制信号是pcsource，选择结果是npc
mux4x32  nextpc  (p4,adr,ra, jpc,pcsource,npc);

/*寄存器组*/
// 定义一个寄存器，输入端口是inst[25:21]即rs(n1)、inst[20:16]即rt(n2)
// 输出端口是data即ra即q1、data即q2
// 输入写使能wreg、待写寄存器wn即n
// 输入时钟clock即clk、清零时钟resetn
regfile  rf   (inst[25:21] ,inst[20:16] ,res,wn,wreg,clock,resetn,ra,data);

/*alu*/
// 操作数是alua、alub，操作结果是aluu空r、标志位zero即z
// 控制信号是aluc
alu  al_unit   (alua,alub,aluc,alu, zero); 
endmodule

sccmop_dataflow.v

/*最顶层的控制模块*/
/*输入时钟clock和resetn*/
/*输出 指令inst、PC的值pc、ALU的运算结果aluout、存储器的输出memout、时钟信号mem_clk*/
module  sccomp_dataflow(clock, resetn, inst, pc, aluout, memout,mem_clk);
input  clock, resetn,mem_clk;
output   [31:0]  inst,pc, aluout,memout;
wire [31:0]   data;
wire   wmem;
// 实例化一个cpu
sccpu_dataflow s (clock, resetn, inst,memout,pc, wmem, aluout, data);
// 实例化一个ROM
scinstmem imem (pc,inst);
// 实例化一个RAM
scdatamem dmem (clock, memout, data, aluout, wmem, mem_clk, mem_clk);
endmodule

好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
2
0
« 上一篇： C++正则表达式
» 下一篇： argparse入门
posted @ 2019-05-28 22:29  小塞  阅读(5341)  评论(2)  编辑  收藏  举报



15



计算机硬件（不深入）

    什么是计算机：

接收用户输入指令和数据，经中央处理器的数据和逻辑单元运算处理后，以产生或存储成有用的信息。

 

    CPU

 

    内含微指令集，以实现相应的功能（如加速多媒体程序的运行、加强虚拟化性能、增加能源效率等）

    cpu分为两个主要的单元：算数逻辑单元、控制单元；前者：程序运算与逻辑判断，后者：协调各组件和各单元的协调配合。

    cpu种类：

根据指令集分：

 

CISC：Intel、AMD等公司开发的x86架构的cpu使用CISC（x86架构是一种cpu架构，因第一款采用这个架构的cpu名为8086而得名），不同的x86架构的cpu有区别：第二层缓存、每次运作可执行的指令数、微指令集等。

 

RISC：Sun公司的SPARC系列、IBM的PowerPC系列、ARM系列（两个教授发明的）。大型工作站、有些服务器、手机、交换机路由器等使用RISC的cpu。

     双核：在一个cpu封装中嵌入了两个运算内核（两个cpu单元）
     cpu的频率：cpu每秒可以进行的工作次数，越高性能越好。但是不同cpu之间不能单纯以频率比较性能，因为微指令集不同、架构也不同，每一次工作执行的指令数不同。外频与倍频相乘为cpu频率。
    字组大小：根据每次cpu解析的字组大小分为32位、64位。
    cpu的外频：与外部组件进行数据传输/运算时的速度，与外部组件的速度一致为最佳。
    cpu的倍频：cpu内运算频率。
    cpu的等级，现在的64位统称为x86_64等级，之前的cpu因为生产年代、技术分为其他的等级。cpu对于软件的支持具有向下兼容的能力。
    高发热，上方安装有风扇。

 

    主板

 

    其上有主板芯片组，将所有设备连接到一起，让所有设备能够进行协调与通信。芯片组也是高发热，南北桥上覆盖有散热片。
    不同的cpu架构导致略有不同的不同主板芯片组的设计。
    芯片组通常分为两个桥接器，即北桥、南桥。

前者连接速度较快的cpu、内存、显卡等，后者连接速度较慢的周边接口硬盘、USB、网卡等。（AMD做了小改动：将内存控制组件集成到cpu中了，而不通过北桥）

    芯片组可分为集成型芯片组和独立型芯片组。
    cpu与其他组件通信（此时考外频）通过总线。

北桥总线称为系统总线，南桥总线称为I/O总线。系统总线支持的频率称为前端总线速度FSB（front side bus）；每次传送的位数是总线宽度（32位/64位）；总线频宽=FSB×总线宽度，即每秒钟可以传送的最大数据量。

    主板上各组件通信需要各组件有I/O地址、IRQ中断信道（I/O地址连接到CPU的专门路径），这样设备可告知CPU该设备的工作情况，以方便CPU分配任务。
    主板上也有与各项输出、输入设备连接的接口设备。
    主板上有CMOS、BIOS、ROM：

 CMOS是芯片，记录了主板的重要参数，包括系统时间、CPU电压和频率、各项设备的I/O地址与IRQ等，这个芯片需要持续供电，故有额外的电源。BIOS是程序，写在闪存上或是EEPROM（一种ROM）上，开机时执行该程序，该程序加载（也可以修改）CMOS中的参数，然后调用ROM中的开机程序，然后进入操作系统。

 

    显卡

 

    内有显示芯片（GPU）和显存。
    GPU做3D运算；显存中存储图形影像的分辨率（像素）、色彩深度信息。
    目前显卡的规格是PCle.

 

    记忆体

    挥发性记忆体（断电后数据消失）

RAM

DRAM：占用资源和空间小，速度较后者慢，需要刷新。在PC中以内存条的形式出现。

SDRAM：速度快，但占用资源多。一般CPU和GPU的缓存由它构成。

 

    非挥发性记忆体（断电后数据依然存在）

ROM：其内内容永远无法改变；用户只能读，不能写入。存储启动电脑的各种指令。

闪存：允许操作中多次擦或写，较硬盘抗震性好。

磁盘：

          硬盘：（必备）根据数据接口不同分为IDE、SATA、SCSI接口等，硬盘内有一个缓冲存储器，将硬盘内常用的数据存储起来，以加速系统的读取性能。

          软盘：（淘汰）

          磁带：（淘汰）

 

    记忆体也具有频率、数据宽度、频宽；DRAM的外频最好和cpu外频一致；内存的容量很重要，越大越好，因为如果内存容量不够大，某些暂时不会用到的数据得先被释放，才能加载目标数据。
    双通道设计：将两个内存整合到一起，就能增加数据宽度，数据同步读入读出这两个内存。

 

    电源

 材料不同、稳定度不同。最好选用高转换率的电池。

 

 
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0

» 下一篇： 操作系统内核（linux）
posted @ 2017-11-19 15:14  小塞  阅读(140)  评论(0)  编辑  收藏  举报




16



操作系统内核（linux）

    操作系统的内核（Kernel）
    是一组程序，这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。
    有了内核后，开发者不必自己去考虑机器语言、所有硬件的相关参数、程序的可移植性、专一性了。但是由于开发者使用的是操作系统提供的接口，所以需要考虑应用将在哪个操作系统中运行。
    内核的功能有：

系统调用接口System call interface：与硬件通信

程序管理Process control：使cpu资源做有效分配

内存管理Memory management

文件管理系统Filesystem management：例如数据输入输出工作、不同文件格式的支持等

设备驱动Device driver：操作系统提供开发接口，硬件厂商参考之设计他们的设备的驱动程序。

    内核程序开机后常驻存在内存中，且该区块受保护。
    一般提及的操作系统包含内核和一些应用软件。

好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 计算机硬件（不深入）
» 下一篇： 与磁盘第一块扇区有关的：分区与开机流程
posted @ 2017-11-19 15:43  小塞  阅读(429)  评论(0)  编辑  收藏  举报



17


与磁盘第一块扇区有关的：分区与开机流程

    引入：

在linux系统中，每个设备都被当成一个文件来对待。

几乎所有硬件设备都在/dev这个目录下。

需要掌握的是磁盘的设备文件名：IDE接口的为/dev/hd[a-d]，SATA的为/dev/sd[a-p]。

那么分区后的设备文件名呢？

 

    磁盘的第一个扇区
    磁盘数据的写入在盘片上，盘片的单位是扇区（512bytes），整块磁盘的第一个扇区最重要，它记录了两个重要的信息：

1.主引导分区（MBR）：稍后谈，446B

2.分区表：记录硬盘分区状态，64B。

    将硬盘的柱面标号，每个分区分配一段连续的柱面。
    64B的分区表划为4个部分（仅有4个哟），每个部分16B，记录四段【起始柱面号码与结束柱面号码】。四个部分中最多有3个主分区，一个拓展分区。
    所谓的“分区”操作实际上只是针对分区表进行设置。主分区表记录的是主分区的柱面信息，拓展分区表记录的是逻辑分区的柱面信息。拓展分区表所占空间大小是64B减去主分区表大小。

e.g.假设现在给一块IDE磁盘/dev/hda分区，决定分为2个主分区（primary），4个逻辑分区（logical）。

第一个扇区的64B分区表可以分为：16B主分区 1、16B主分区2、32B拓展分区。

主分区1记录的主分区1对应文件名/dev/hda1，主分区2记录的主分区2对应文件名/dev/hda2，拓展分区记录的逻辑分区1对应文件名/dev/hda5，拓展分区记录的逻辑分区2对应文件名/dev/hda6，拓展分区记录的逻辑分区3对应文件名/dev/hda7，拓展分区记录的逻辑分区4对应文件名/dev/hda8.

    逻辑分区个数有上限，IDE59；SATA11。
    分区完成后，只能够再整合逻辑分区内的两个或多个分区，不能将主分区与逻辑分区整合。
    每个分区都有自己的启动分区。

 

    开机流程（较第一篇随笔中提及的详细点的）：
    BIOS读完CMOS里的参数后，开始找硬盘（或是其他存储设备），找到后，读取第一个扇区的446B的MBR。BIOS结束工作。
    MBR内存储着基本引导加载程序Boot loade（CentOS的引导加载程序是grub软件）r。引导加载程序开始工作。引导加载程序在安装操作系统时获得。
    MBR的引导加载程序可以提供多个菜单，例如：菜单一：直接加载XX内核文件，菜单二：将引导加载工作交给XX分区的启动扇区，菜单三：将引导加载工作交给XX分区的启动扇区。（XX内填什么，在安装操作系统时设置）。菜单一必不可少，如果只有菜单一，就直接加载内核。
    多个内核文件必须放在不同的分区中。

好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 操作系统内核（linux）
» 下一篇： 安装linux时的分区问题，需要了解目录树及挂载知识
posted @ 2017-11-19 15:51  小塞  阅读(1534)  评论(0)  编辑  收藏  举报



18


安装linux时的分区问题，需要了解目录树及挂载知识

    Linux是目录树架构，如何结合目录树架构与磁盘内的数据→挂载。

Linux先有目录，后有磁盘分区。数据（文件）依存于目录。

目录为挂载点，磁盘分区的数据放置在该目录下，进入该目录，就可以读取该分区。

根目录挂载到某分区后，若其下的子目录没有另设挂载点，都挂在根目录的分区。

合适的分区方式：

将需要较大容量的目录、读写较为频繁的目录等重要的目录单独设置挂载点，这样当这些目录对应的磁盘分区有问题时，不会影响到根目录。例如：/usr、/home、/var、Swap，这与自己的需求有关。
 

    Linux支持多种文件系统类型：

ext3：日志文件系统

LVM：弹性调整文件系统大小而不改变数据内容

software RAID：可用软件仿真出磁盘阵列的功能

swap：内存交换空间（重要，可以避免因为物理内存不足而造成的系统效能降低的问题，因为不常用的数据会被丢在swap中。但是内存4GB及以上，不设swap也OK），swap目录不会用到目录树的挂载，所以对应的文件系统为swap文件系统。

vflat：同时被linux和s支持的文件系统类型，若电脑同时存在这两个系统，为了数据交换，可以构建一个vflat系统。

 

    装机时的分区操作是：

给目录分配磁盘空间，若给某目录设置“强制为主分区”，该主分区如/dev/hda1将挂在该目录下。如果不选择该项，系统会将分区表剩余空间变成拓展分区，不选择该项的目录将分配到/dev/hda5之类的逻辑分区。
 

    安装Linux还需注意的地方：

笔记本电脑和其他类PC上如果安装适用于一般桌面计算机的linux，可能会出现一些问题。因为电源管理方式、显卡集成与否等有差别。这时需要加入一些参数，关闭linux的某些安装时的操作。

SELinux要打开；

Kdump要关闭；

多重引导安装（暂时略）；

大硬盘导致无法开机的问题（暂时略）。
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 与磁盘第一块扇区有关的：分区与开机流程
» 下一篇： 如何理解linux多用户多任务
posted @ 2017-11-19 15:56  小塞  阅读(1276)  评论(0)  编辑  收藏  举报



19



    博客园
    首页
    新随笔
    联系
    订阅
    管理

随笔 - 20  文章 - 0  评论 - 12  阅读 - 90946
如何理解linux多用户多任务

    Linux 的单用户、多任务：

容易理解。
 

    Linux 的多用户、多任务

举个例子，比如LinuxSir.Org 服务器，上面有FTP 用户、系统管理员、web 用户、常规普通用户等。在同一时刻，比如系统管理员和FTP用户在管理他们的主页系统和FTP ，nobody 用户浏览主页下载文件，超级管理员的对系统的维护或查看。

即为：多用户多任务。

之所以能够如此是因为，不同用户所具有的权限不同。不同的用户在这台服务器上进行的工作不一样。只要有用户权限任何人都是可以上去操作或访问的。

多用户可能通过远程登录来进行，如对服务器的远程控制。

 
3、用户的角色区分

用户在系统中是分角色的，在Linux 系统中，由于角色不同，权限和所完成的任务也不同。

root 用户：系统唯一，是真实的，可以登录系统，可以操作系统任何文件和命令，拥有最高权限；

普通真实用户：这类用户能登录系统，但只能操作自己家目录的内容；权限有限；这类用户都是系统管理员自行添加的；

虚拟用户：这类用户也被称之为伪用户或假用户，与真实用户区分开来，这类用户不具有登录系统的能力，但却是系统运行不可缺少的用户，比如bin、daemon、adm、ftp、mail等；这类用户都系统自身拥有的，而非后来添加的，当然我们也可以添加虚拟用户；
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
1
0
« 上一篇： 安装linux时的分区问题，需要了解目录树及挂载知识
» 下一篇： disasters
posted @ 2017-11-19 16:00  小塞  阅读(2752)  评论(0)  编辑  收藏  举报



20


disasters
1.list all the natural disasters to the best of your knowledge.
2.What are the possible causes for some of the disasters?
3.How to surve in an earthquake/big fire?
 
Geological disasters地质灾害
Avalanches and landside雪崩和山体滑坡
Earthquake
Volcanic eruptions火山喷发
Hydrological disasters水文灾害
Floods洪水
Tsunami海啸
Meteorological disasters气象灾害
Blizzards暴风雪
Droughts干旱
Thunderstorms雷暴
Hailstorms雹暴
Heat waves热浪
Tornadoes龙卷风
Wildfires森林大火
一些灾难的原因：
 

select me
 
 

select me
地震逃生：
 

select me
 
火灾逃生： lower your body and at the same time use a wet towel to cover your mouth and nose.Don’t jump from a high building.You can fasten ropes or sheets to some firm things and slide down the ropes or sheets.Don’t be unwilling to leave your money behind.You should run away from the fire as quickly as you can.After all,life is more important than money.Once you get out of the fire,don’t return to it again.
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 如何理解linux多用户多任务
» 下一篇： jupyter notebook dead kernel问题解决
posted @ 2018-03-29 17:09  小塞  阅读(170)  评论(0)  编辑  收藏  举报



21

jupyter notebook dead kernel问题解决
背景：

我在刚安装好的tensorflow环境下启动jupyter notebook，无论是浏览器还是控制台，提示都是关于dead kernel。然后就查嘛，更新大发好。

但是我在控制台里按照其他人说的方法更新都没有成功更新，应该是他们的conda命令没有写全的原因。

我又想到，navigator里好像可以更新，不用conda命令也行，然后就摸索到下面一番操作，最后成功地更新了几个package。再次打开jupyter，也一切正常了。
思路：

更新jupyter notebook、ipython、ipythonkernel （很多人没有提到这个，但是这个特别必要，我一开始只更新了前两个，没有成功；三个全更新了才成功）
方法：

1. 打开Anaconda Navigator

2. 找到对应环境下可更新的包

3. 这样更新：

把Notebook、ipython、ipythonkernel都选中之后，到selected里查看自己选全没有，没有的话继续选

 

然后apply就行了

 

（完）
标签: jupyter, dead kernel
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： disasters
» 下一篇： C++正则表达式
posted @ 2019-03-30 13:36  小塞  阅读(7244)  评论(1)  编辑  收藏  举报




22


argparse入门

目录

    入门argparse模块
        步骤
            零、import argparse
            一、定义parser
            二、定义参数
            三、取出参数
            四、定义模式
            五、取出模式
        示例

入门argparse模块

这个模块其实很简单的，不要有畏惧心理。只需要0、1、2、3、4、5个步骤就可以掌握了。
步骤
零、import argparse
一、定义parser

parser = argparse.ArgumentParser(description='Calculate volume of a Cylinder')
## decription中的内容将出现在help命令下

二、定义参数

# 位置参数：
parser.add_argument('radius')
# 名称参数：
parse.add_argument('-r', '--radius')
# 必选参数：默认参数可选。add_argument时传入参数“require=True”
# 参数类型：默认字符串类型。add_argument时传入参数“type=int”
# 在help中显示该参数的解释：默认无解释。add_argument时传入参数“help='Radius of a Cylinder'”

三、取出参数

args = parser.parse_args()
args.radius

四、定义模式

group = parse.add_mutually_exclusive_group()
group.add_argument('-q', '--quiet', action='store_true', help='print quiet')
group.add_argument('-v', '--verbose', action='store_true', help='print verbose')
# 以上代码定义了一个quiet模式，一个verbose模式
# 在既不输入-q也不输入-v时进入默认模式
# action='store_true'的作用：如果输入-q或--quiet，该模式的值即为True（见五）

五、取出模式

args.quiet ## 如果输入-q或--quiet，args.quiet=True，否则为False
# 

示例

好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： 单周期cpu设计代码解读
» 下一篇： Python引用与目录结构
posted @ 2019-07-08 15:17  小塞  阅读(734)  评论(0)  编辑  收藏  举报



23



    博客园
    首页
    新随笔
    联系
    订阅
    管理

随笔 - 20  文章 - 0  评论 - 12  阅读 - 90946
Python引用与目录结构

目录

    Python引用与目录结构
        模块的概念
        包的概念
        引用时搜索模块的顺序
        python工程常用目录结构
        参考资料


哎。差点找不到之前写的这篇笔记。

Python引用与目录结构
模块的概念

模块即单个.py文件。
模块名即文件名。

引用模块：

    只在第一次引用时执行、且执行一次。

    引用及使用方法：

    # 仅引模块
    import module
    m1.fun() ##使用其内变量/函数，必须使用"模块名."。否则报错

    # 引模块的特定变量/函数
    from module import fun
    fun()　##不必使用"模块名."

模块也是对象，具有一个内置属性__name__。该属性有两种取值：模块名、__main__。

    举例说明取值问题：当在A文件中引入B模块，A文件的__name__取值为__main__，B模块的__name__取值为模块名。

    __name__的使用场景：在import模块时，默认情况下，模块的所有语句都会被执行一次。如果希望模块中有某些语句，在import时避免执行，可以：

    if __name__ == 'main':
        ## 这里的语句将在import时避免执行
        ## 因为import时，条件为假

包的概念

包即一个文件夹。
包含了__init__.py和一系列.py文件。包名即文件夹名。

__init__.py是为了避免将文件夹名当作普通的字符串，其内容可以为空，一般用来进行包的某些初始化工作或者设置__all__值，用以暴露该包的 API。
引用时搜索模块的顺序

    当前文件所在目录
    环境变量PYTHONPATH（包含python带的模块、自己安装的模块），可以通过bash或sys.path修改

python工程常用目录结构

    方式一

    -- src
        |-- mod1.py（被引用的模块）
        `-- test1.py（主程序）

    在test1.py中直接import mod1即可。

    方式二：

    -- src
        |-- mod1.py（被引用的模块1）
        |-- pkg
        |	|-- __init__.py（必须有）
        |   `-- mod2.py（被引用的模块2）
        `-- test1.py（主程序）

    在test1.py中import mod1

    在test1.py中from pkg import mod2

    方式三：

    -- src
        |-- mod1.py
        |-- pkg
        |	|-- __init__.py（必须有）
        |   `-- mod2.py
        |-- sub
        |   `-- test2.py
        `-- test1.py

    在test1.py中import mod1

    在test1.py中from pkg import mod2

    在test2.py中

    import sys
    sys.path.append("..") ## 临时加入父目录
    ## 然后就可以正常地：
    import mod1
    from pkg import mod2

    在test1.py中from pkg import mod2

参考资料
好文要顶 关注我 收藏该文
小塞
关注 - 1
粉丝 - 12
+加关注
0
0
« 上一篇： argparse入门
» 下一篇： 【从踩坑到教程】win10下ubuntu18.04双系统UEFI模式安装、Nvidia驱动安装
posted @ 2019-07-08 15:57  小塞  阅读(1913)  评论(0)  编辑  收藏  举报








